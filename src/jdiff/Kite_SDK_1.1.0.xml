<?xml version="1.0" encoding="iso-8859-1" standalone="no"?>
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<!-- on Tue Jun 16 09:37:54 PDT 2015 -->

<api
  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
  xsi:noNamespaceSchemaLocation='api.xsd'
  name="Kite SDK 1.1.0"
  jdversion="1.1.1">

<!--  Command line arguments =  -doclet jdiff.JDiff -docletpath /home/blue/workspace/kite/lib/jdiff.jar -classpath /home/blue/workspace/kite/target/classes:/home/blue/workspace/kite/kite-hadoop-dependencies/target/classes:/home/blue/workspace/kite/kite-hadoop-dependencies/default/target/classes:/home/blue/workspace/kite/kite-hadoop-dependencies/default-test/target/classes:/home/blue/workspace/kite/kite-hadoop-dependencies/hadoop1/target/classes:/home/blue/workspace/kite/kite-hadoop-dependencies/hadoop1-test/target/classes:/home/blue/workspace/kite/kite-hadoop-dependencies/cdh4/target/classes:/home/blue/workspace/kite/kite-hadoop-dependencies/cdh4-test/target/classes:/home/blue/workspace/kite/kite-hadoop-dependencies/cdh5/target/classes:/home/blue/workspace/kite/kite-hadoop-dependencies/cdh5-test/target/classes:/home/blue/workspace/kite/kite-hadoop-compatibility/target/classes:/home/blue/workspace/kite/kite-hbase-dependencies/target/classes:/home/blue/workspace/kite/kite-hbase-dependencies/default/target/classes:/home/blue/workspace/kite/kite-hbase-dependencies/default-test/target/classes:/home/blue/workspace/kite/kite-hbase-dependencies/hadoop1/target/classes:/home/blue/workspace/kite/kite-hbase-dependencies/hadoop1-test/target/classes:/home/blue/workspace/kite/kite-hbase-dependencies/cdh4/target/classes:/home/blue/workspace/kite/kite-hbase-dependencies/cdh4-test/target/classes:/home/blue/workspace/kite/kite-hbase-dependencies/cdh5/target/classes:/home/blue/workspace/kite/kite-hbase-dependencies/cdh5-test/target/classes:/home/blue/workspace/kite/kite-data/target/classes:/home/blue/workspace/kite/kite-data/kite-data-core/target/classes:/home/blue/workspace/kite/kite-data/kite-data-oozie/target/classes:/home/blue/workspace/kite/kite-data/kite-data-hive/target/classes:/home/blue/workspace/kite/kite-data/kite-data-s3/target/classes:/home/blue/workspace/kite/kite-data/kite-data-hbase/target/classes:/home/blue/workspace/kite/kite-data/kite-data-mapreduce/target/classes:/home/blue/workspace/kite/kite-data/kite-data-crunch/target/classes:/home/blue/workspace/kite/kite-data/kite-data-flume/target/classes:/home/blue/workspace/kite/kite-data/kite-data-spark/target/classes:/home/blue/workspace/kite/kite-app-parent/cdh4/target/classes:/home/blue/workspace/kite/kite-app-parent/cdh5/target/classes:/home/blue/workspace/kite/kite-app-parent/target/classes:/home/blue/workspace/kite/kite-maven-plugin/target/classes:/home/blue/workspace/kite/kite-tools-parent/target/classes:/home/blue/workspace/kite/kite-tools-parent/kite-tools/target/classes:/home/blue/workspace/kite/kite-minicluster/target/classes:/home/blue/workspace/kite/kite-tools-parent/kite-tools-cdh5/target/classes:/home/blue/workspace/kite/kite-morphlines/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-core/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-avro/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-json/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-maxmind/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-metrics-servlets/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-protobuf/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-saxon/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-tika-core/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-tika-decompress/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-twitter/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-hadoop-core/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-hadoop-parquet-avro/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-hadoop-rcfile/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-hadoop-sequencefile/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-useragent/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-solr-core/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-solr-cell/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-all/target/classes:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-all-except-solr/target/classes:/home/blue/.m2/repository/net/jpountz/lz4/lz4/1.2.0/lz4-1.2.0.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-yarn-server-common/2.6.0-cdh5.4.2/hadoop-yarn-server-common-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/javax/servlet/javax.servlet-api/3.0.1/javax.servlet-api-3.0.1.jar:/home/blue/.m2/repository/org/codehaus/jackson/jackson-core-asl/1.9.13/jackson-core-asl-1.9.13.jar:/home/blue/.m2/repository/classworlds/classworlds/1.1-alpha-2/classworlds-1.1-alpha-2.jar:/home/blue/.m2/repository/org/fusesource/leveldbjni/leveldbjni-all/1.8/leveldbjni-all-1.8.jar:/home/blue/.m2/repository/org/scala-lang/scalap/2.10.0/scalap-2.10.0.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-client/1.0.0-cdh5.4.2/hbase-client-1.0.0-cdh5.4.2.jar:/home/blue/.m2/repository/commons-pool/commons-pool/1.5.4/commons-pool-1.5.4.jar:/home/blue/.m2/repository/org/apache/solr/solr-core/4.10.3/solr-core-4.10.3.jar:/home/blue/.m2/repository/com/github/stephenc/findbugs/findbugs-annotations/1.3.9-1/findbugs-annotations-1.3.9-1.jar:/home/blue/.m2/repository/com/linkedin/haivvreo/1.0.7-cdh-4/haivvreo-1.0.7-cdh-4.jar:/home/blue/.m2/repository/com/sun/jersey/jersey-client/1.9/jersey-client-1.9.jar:/home/blue/.m2/repository/com/googlecode/concurrentlinkedhashmap/concurrentlinkedhashmap-lru/1.2/concurrentlinkedhashmap-lru-1.2.jar:/home/blue/.m2/repository/org/apache/calcite/calcite-core/1.0.0-incubating/calcite-core-1.0.0-incubating.jar:/home/blue/.m2/repository/org/apache/maven/maven-plugin-api/2.0.6/maven-plugin-api-2.0.6.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-yarn-client/2.6.0-cdh5.4.2/hadoop-yarn-client-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/javax/xml/stream/stax-api/1.0-2/stax-api-1.0-2.jar:/home/blue/.m2/repository/org/apache/httpcomponents/httpmime/4.3.1/httpmime-4.3.1.jar:/home/blue/.m2/repository/org/apache/spark/spark-core_2.10/1.3.0-cdh5.4.2/spark-core_2.10-1.3.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/maven/maven-core/3.0/maven-core-3.0.jar:/home/blue/.m2/repository/commons-collections/commons-collections/3.2.1/commons-collections-3.2.1.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-yarn-common/2.6.0-cdh5.4.2/hadoop-yarn-common-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/antlr/ST4/4.0.4/ST4-4.0.4.jar:/home/blue/.m2/repository/net/sourceforge/collections/collections-generic/4.01/collections-generic-4.01.jar:/home/blue/.m2/repository/org/apache/calcite/calcite-linq4j/1.0.0-incubating/calcite-linq4j-1.0.0-incubating.jar:/home/blue/.m2/repository/org/apache/poi/poi-ooxml-schemas/3.10.1/poi-ooxml-schemas-3.10.1.jar:/home/blue/.m2/repository/org/datanucleus/datanucleus-core/3.2.10/datanucleus-core-3.2.10.jar:/home/blue/.m2/repository/com/twitter/parquet-encoding/1.6.0/parquet-encoding-1.6.0.jar:/home/blue/.m2/repository/org/apache/tika/tika-core/1.5/tika-core-1.5.jar:/home/blue/.m2/repository/org/sonatype/aether/aether-impl/1.7/aether-impl-1.7.jar:/home/blue/.m2/repository/org/glassfish/grizzly/grizzly-rcm/2.1.2/grizzly-rcm-2.1.2.jar:/home/blue/.m2/repository/org/codehaus/jackson/jackson-jaxrs/1.9.13/jackson-jaxrs-1.9.13.jar:/home/blue/.m2/repository/org/apache/mesos/mesos/0.21.0/mesos-0.21.0-shaded-protobuf.jar:/home/blue/.m2/repository/net/sf/kosmosfs/kfs/0.3/kfs-0.3.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-twitter/1.1.0/kite-morphlines-twitter-1.1.0.jar:/home/blue/.m2/repository/org/noggit/noggit/0.5/noggit-0.5.jar:/home/blue/.m2/repository/org/apache/avro/trevni-avro/1.7.4/trevni-avro-1.7.4.jar:/home/blue/.m2/repository/org/mortbay/jetty/jetty/6.1.26.cloudera.4/jetty-6.1.26.cloudera.4.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-maxmind/1.1.0/kite-morphlines-maxmind-1.1.0.jar:/home/blue/.m2/repository/org/restlet/jee/org.restlet.ext.servlet/2.1.1/org.restlet.ext.servlet-2.1.1.jar:/home/blue/.m2/repository/org/glassfish/external/management-api/3.0.0-b012/management-api-3.0.0-b012.jar:/home/blue/.m2/repository/com/spatial4j/spatial4j/0.4.1/spatial4j-0.4.1.jar:/home/blue/.m2/repository/com/codahale/metrics/metrics-healthchecks/3.0.2/metrics-healthchecks-3.0.2.jar:/home/blue/.m2/repository/org/apache/hive/shims/hive-shims-0.20/0.13.0/hive-shims-0.20-0.13.0.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-yarn-server-applicationhistoryservice/2.6.0-cdh5.4.2/hadoop-yarn-server-applicationhistoryservice-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-solr-cell/1.1.0/kite-morphlines-solr-cell-1.1.0.jar:/home/blue/.m2/repository/com/codahale/metrics/metrics-servlets/3.0.2/metrics-servlets-3.0.2.jar:/home/blue/.m2/repository/org/apache/oozie/oozie-core/4.1.0/oozie-core-4.1.0.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-deploy/8.1.10.v20130312/jetty-deploy-8.1.10.v20130312.jar:/home/blue/.m2/repository/org/codehaus/plexus/plexus-container-default/1.0-alpha-9-stable-1/plexus-container-default-1.0-alpha-9-stable-1.jar:/home/blue/.m2/repository/org/apache/avro/avro-ipc/1.7.5/avro-ipc-1.7.5-tests.jar:/home/blue/.m2/repository/org/apache/hive/hive-exec/1.1.0-cdh5.4.2/hive-exec-1.1.0-cdh5.4.2.jar:/home/blue/.m2/repository/com/googlecode/juniversalchardet/juniversalchardet/1.0.3/juniversalchardet-1.0.3.jar:/home/blue/.m2/repository/org/sonatype/aether/aether-spi/1.7/aether-spi-1.7.jar:/home/blue/.m2/repository/org/json4s/json4s-core_2.10/3.2.10/json4s-core_2.10-3.2.10.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-hadoop2-compat/1.0.0-cdh5.4.2/hbase-hadoop2-compat-1.0.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/cloudera/htrace/htrace-core/2.04/htrace-core-2.04.jar:/home/blue/.m2/repository/org/apache/htrace/htrace-core/3.1.0-incubating/htrace-core-3.1.0-incubating.jar:/home/blue/.m2/repository/org/apache/maven/maven-settings/2.0.6/maven-settings-2.0.6.jar:/home/blue/.m2/repository/org/apache/maven/wagon/wagon-provider-api/1.0-beta-2/wagon-provider-api-1.0-beta-2.jar:/home/blue/.m2/repository/com/sun/jersey/jersey-servlet/1.14/jersey-servlet-1.14.jar:/home/blue/.m2/repository/commons-fileupload/commons-fileupload/1.2.1/commons-fileupload-1.2.1.jar:/home/blue/.m2/repository/org/mortbay/jetty/jsp-2.1/6.1.14/jsp-2.1-6.1.14.jar:/home/blue/.m2/repository/org/apache/tika/tika-xmp/1.5/tika-xmp-1.5.jar:/home/blue/.m2/repository/org/schwering/irclib/1.10/irclib-1.10.jar:/home/blue/.m2/repository/commons-el/commons-el/1.0/commons-el-1.0.jar:/home/blue/.m2/repository/jline/jline/2.12/jline-2.12.jar:/home/blue/.m2/repository/org/bouncycastle/bcmail-jdk15/1.45/bcmail-jdk15-1.45.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-yarn-server-nodemanager/2.6.0-cdh5.4.2/hadoop-yarn-server-nodemanager-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/jruby/jruby-complete/1.6.5/jruby-complete-1.6.5.jar:/home/blue/.m2/repository/org/jboss/netty/netty/3.2.4.Final/netty-3.2.4.Final.jar:/home/blue/.m2/repository/commons-beanutils/commons-beanutils-core/1.8.0/commons-beanutils-core-1.8.0.jar:/home/blue/.m2/repository/org/apache/maven/plugin-tools/maven-plugin-annotations/3.1/maven-plugin-annotations-3.1.jar:/home/blue/.m2/repository/de/l3s/boilerpipe/boilerpipe/1.1.0/boilerpipe-1.1.0.jar:/home/blue/.m2/repository/org/apache/thrift/libfb303/0.9.2/libfb303-0.9.2.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-hadoop-core/1.1.0/kite-morphlines-hadoop-core-1.1.0.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-testing-util/1.0.0-cdh5.4.2/hbase-testing-util-1.0.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/avro/avro-mapred/1.7.5/avro-mapred-1.7.5-hadoop2.jar:/home/blue/.m2/repository/org/apache/avro/avro-mapred/1.7.5/avro-mapred-1.7.5-hadoop1.jar:/home/blue/.m2/repository/asm/asm-commons/3.1/asm-commons-3.1.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-tika-core/1.1.0/kite-morphlines-tika-core-1.1.0.jar:/home/blue/.m2/repository/org/apache/pdfbox/pdfbox/1.8.4/pdfbox-1.8.4.jar:/home/blue/.m2/repository/com/sun/xml/bind/jaxb-impl/2.2.3-1/jaxb-impl-2.2.3-1.jar:/home/blue/.m2/repository/org/htrace/htrace-core/3.0.4/htrace-core-3.0.4.jar:/home/blue/.m2/repository/org/spark-project/akka/akka-remote_2.10/2.2.3-shaded-protobuf/akka-remote_2.10-2.2.3-shaded-protobuf.jar:/home/blue/.m2/repository/asm/asm-tree/3.1/asm-tree-3.1.jar:/home/blue/.m2/repository/commons-io/commons-io/2.4/commons-io-2.4.jar:/home/blue/.m2/repository/org/apache/solr/solr-cell/4.10.3/solr-cell-4.10.3.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-continuation/8.1.14.v20131031/jetty-continuation-8.1.14.v20131031.jar:/home/blue/.m2/repository/com/carrotsearch/hppc/0.5.2/hppc-0.5.2.jar:/home/blue/.m2/repository/org/gagravarr/vorbis-java-core/0.1/vorbis-java-core-0.1.jar:/home/blue/.m2/repository/org/apache/avro/avro/1.7.6-cdh5.4.2/avro-1.7.6-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/hive/hive-contrib/0.10.0-cdh4.4.0/hive-contrib-0.10.0-cdh4.4.0.jar:/home/blue/.m2/repository/org/eclipse/jetty/orbit/javax.mail.glassfish/1.4.1.v201005082020/javax.mail.glassfish-1.4.1.v201005082020.jar:/home/blue/.m2/repository/org/apache/hive/hive-shims/1.1.0-cdh5.4.2/hive-shims-1.1.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/maven/maven-plugin-registry/2.0.6/maven-plugin-registry-2.0.6.jar:/home/blue/.m2/repository/concurrent/concurrent/1.3.4/concurrent-1.3.4.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-jmx/8.1.10.v20130312/jetty-jmx-8.1.10.v20130312.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-app/2.6.0-cdh5.4.2/hadoop-mapreduce-client-app-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/datanucleus/datanucleus-connectionpool/2.0.3/datanucleus-connectionpool-2.0.3.jar:/home/blue/.m2/repository/org/scala-lang/scala-library/2.10.4/scala-library-2.10.4.jar:/home/blue/.m2/repository/org/eclipse/jetty/orbit/javax.servlet/3.0.0.v201112011016/javax.servlet-3.0.0.v201112011016.jar:/home/blue/.m2/repository/org/glassfish/grizzly/grizzly-http-server/2.1.2/grizzly-http-server-2.1.2.jar:/home/blue/.m2/repository/org/apache/flume/flume-ng-channels/flume-file-channel/1.5.0-cdh5.4.2/flume-file-channel-1.5.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-xml/8.1.14.v20131031/jetty-xml-8.1.14.v20131031.jar:/home/blue/.m2/repository/org/apache/directory/api/api-util/1.0.0-M20/api-util-1.0.0-M20.jar:/home/blue/.m2/repository/commons-codec/commons-codec/1.4/commons-codec-1.4.jar:/home/blue/.m2/repository/org/apache/directory/server/apacheds-i18n/2.0.0-M15/apacheds-i18n-2.0.0-M15.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-client/2.6.0-cdh5.4.2/hadoop-client-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/zookeeper/zookeeper/3.4.6/zookeeper-3.4.6.jar:/home/blue/.m2/repository/org/apache/hive/shims/hive-shims-0.23/1.1.0-cdh5.4.2/hive-shims-0.23-1.1.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/gagravarr/vorbis-java-tika/0.1/vorbis-java-tika-0.1.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-hadoop-rcfile/1.1.0/kite-morphlines-hadoop-rcfile-1.1.0.jar:/home/blue/.m2/repository/com/google/inject/guice/3.0/guice-3.0.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-io/8.1.14.v20131031/jetty-io-8.1.14.v20131031.jar:/home/blue/.m2/repository/junit/junit/4.11/junit-4.11.jar:/home/blue/.m2/repository/org/roaringbitmap/RoaringBitmap/0.4.5/RoaringBitmap-0.4.5.jar:/home/blue/.m2/repository/com/twitter/parquet-format/2.2.0-rc1/parquet-format-2.2.0-rc1.jar:/home/blue/.m2/repository/org/apache/thrift/libthrift/0.9.2/libthrift-0.9.2.jar:/home/blue/.m2/repository/com/esotericsoftware/minlog/minlog/1.2/minlog-1.2.jar:/home/blue/.m2/repository/xerces/xercesImpl/2.10.0/xercesImpl-2.10.0.jar:/home/blue/.m2/repository/com/beust/jcommander/1.35/jcommander-1.35.jar:/home/blue/.m2/repository/com/google/inject/extensions/guice-servlet/3.0/guice-servlet-3.0.jar:/home/blue/.m2/repository/com/clearspring/analytics/stream/2.7.0/stream-2.7.0.jar:/home/blue/.m2/repository/org/apache/maven/maven-model/2.0.6/maven-model-2.0.6.jar:/home/blue/.m2/repository/org/json4s/json4s-jackson_2.10/3.2.10/json4s-jackson_2.10-3.2.10.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-util/8.1.14.v20131031/jetty-util-8.1.14.v20131031.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-json/1.1.0/kite-morphlines-json-1.1.0.jar:/home/blue/.m2/repository/org/jruby/jcodings/jcodings/1.0.8/jcodings-1.0.8.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-suggest/4.10.3/lucene-suggest-4.10.3.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-prefix-tree/1.0.0-cdh5.4.2/hbase-prefix-tree-1.0.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/maven/maven-profile/2.0.6/maven-profile-2.0.6.jar:/home/blue/.m2/repository/javax/jdo/jdo2-api/2.3-ec/jdo2-api-2.3-ec.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-plus/8.1.14.v20131031/jetty-plus-8.1.14.v20131031.jar:/home/blue/.m2/repository/org/spark-project/akka/akka-actor_2.10/2.2.3-shaded-protobuf/akka-actor_2.10-2.2.3-shaded-protobuf.jar:/home/blue/.m2/repository/org/cloudera/logredactor/logredactor/1.0.2/logredactor-1.0.2.jar:/home/blue/.m2/repository/org/mortbay/jetty/jetty-sslengine/6.1.26.cloudera.4/jetty-sslengine-6.1.26.cloudera.4.jar:/home/blue/.m2/repository/org/apache/mina/mina-core/2.0.4/mina-core-2.0.4.jar:/home/blue/.m2/repository/org/eclipse/jetty/aggregate/jetty-all/7.6.0.v20120127/jetty-all-7.6.0.v20120127.jar:/home/blue/.m2/repository/org/jamon/jamon-runtime/2.3.1/jamon-runtime-2.3.1.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-test/2.6.0-mr1-cdh5.4.2/hadoop-test-2.6.0-mr1-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/tika/tika-parsers/1.5/tika-parsers-1.5.jar:/home/blue/.m2/repository/org/glassfish/grizzly/grizzly-http/2.1.2/grizzly-http-2.1.2.jar:/home/blue/.m2/repository/com/sun/jersey/contribs/jersey-guice/1.9/jersey-guice-1.9.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-analyzers-common/4.10.3/lucene-analyzers-common-4.10.3.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-codecs/4.10.3/lucene-codecs-4.10.3.jar:/home/blue/.m2/repository/com/uwyn/jhighlight/1.0/jhighlight-1.0.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-misc/4.10.3/lucene-misc-4.10.3.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-security/8.1.14.v20131031/jetty-security-8.1.14.v20131031.jar:/home/blue/.m2/repository/org/apache/solr/solr-solrj/4.10.3/solr-solrj-4.10.3.jar:/home/blue/.m2/repository/commons-lang/commons-lang/2.6/commons-lang-2.6.jar:/home/blue/.m2/repository/org/apache/commons/commons-math/2.1/commons-math-2.1.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-common/2.6.0-cdh5.4.2/hadoop-mapreduce-client-common-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/poi/poi/3.10.1/poi-3.10.1.jar:/home/blue/.m2/repository/org/apache/oozie/oozie-hcatalog/0.13.1.oozie-4.1.0/oozie-hcatalog-0.13.1.oozie-4.1.0.jar:/home/blue/.m2/repository/org/apache/flume/flume-ng-node/1.5.0-cdh5.4.2/flume-ng-node-1.5.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/geronimo/specs/geronimo-jpa_2.0_spec/1.1/geronimo-jpa_2.0_spec-1.1.jar:/home/blue/.m2/repository/com/lmax/disruptor/3.3.0/disruptor-3.3.0.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-server/8.1.14.v20131031/jetty-server-8.1.14.v20131031.jar:/home/blue/.m2/repository/com/fasterxml/jackson/core/jackson-annotations/2.3.1/jackson-annotations-2.3.1.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-hadoop-sequencefile/1.1.0/kite-morphlines-hadoop-sequencefile-1.1.0.jar:/home/blue/.m2/repository/org/sonatype/sisu/sisu-inject-bean/1.4.2/sisu-inject-bean-1.4.2.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-shuffle/2.6.0-cdh5.4.2/hadoop-mapreduce-client-shuffle-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-common/1.0.0-cdh5.4.2/hbase-common-1.0.0-cdh5.4.2-tests.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-core/2.6.0-mr1-cdh5.4.2/hadoop-core-2.6.0-mr1-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/ftpserver/ftplet-api/1.0.0/ftplet-api-1.0.0.jar:/home/blue/.m2/repository/c3p0/c3p0/0.9.1.1/c3p0-0.9.1.1.jar:/home/blue/.m2/repository/org/apache/hbase/hbase/0.94.6-cdh4.4.0/hbase-0.94.6-cdh4.4.0.jar:/home/blue/.m2/repository/stax/stax-api/1.0.1/stax-api-1.0.1.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-expressions/4.10.3/lucene-expressions-4.10.3.jar:/home/blue/.m2/repository/org/apache/commons/commons-compress/1.4.1/commons-compress-1.4.1.jar:/home/blue/.m2/repository/org/bouncycastle/bcprov-jdk15/1.45/bcprov-jdk15-1.45.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-queryparser/4.10.3/lucene-queryparser-4.10.3.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-annotations/1.0.0-cdh5.4.2/hbase-annotations-1.0.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/ant/ant/1.9.1/ant-1.9.1.jar:/home/blue/.m2/repository/com/github/stephenc/high-scale-lib/high-scale-lib/1.1.1/high-scale-lib-1.1.1.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-grouping/4.10.3/lucene-grouping-4.10.3.jar:/home/blue/.m2/repository/org/apache/avro/avro-mapred/1.7.4/avro-mapred-1.7.4.jar:/home/blue/.m2/repository/oro/oro/2.0.8/oro-2.0.8.jar:/home/blue/.m2/repository/org/apache/curator/curator-framework/2.7.1/curator-framework-2.7.1.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-server/1.0.0-cdh5.4.2/hbase-server-1.0.0-cdh5.4.2-tests.jar:/home/blue/.m2/repository/javax/transaction/jta/1.1/jta-1.1.jar:/home/blue/.m2/repository/com/google/code/gson/gson/2.2.4/gson-2.2.4.jar:/home/blue/.m2/repository/org/apache/flume/flume-ng-channels/flume-spillable-memory-channel/1.5.0-cdh5.4.2/flume-spillable-memory-channel-1.5.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/eclipse/jetty/orbit/javax.transaction/1.1.1.v201105210645/javax.transaction-1.1.1.v201105210645.jar:/home/blue/.m2/repository/org/apache/geronimo/specs/geronimo-jms_1.1_spec/1.1.1/geronimo-jms_1.1_spec-1.1.1.jar:/home/blue/.m2/repository/com/twitter/parquet-hive-bundle/1.6.0/parquet-hive-bundle-1.6.0.jar:/home/blue/.m2/repository/org/datanucleus/datanucleus-enhancer/2.0.3/datanucleus-enhancer-2.0.3.jar:/home/blue/.m2/repository/org/sonatype/plexus/plexus-sec-dispatcher/1.3/plexus-sec-dispatcher-1.3.jar:/home/blue/.m2/repository/org/apache/geronimo/specs/geronimo-annotation_1.0_spec/1.1.1/geronimo-annotation_1.0_spec-1.1.1.jar:/home/blue/.m2/repository/org/apache/poi/poi-ooxml/3.10.1/poi-ooxml-3.10.1.jar:/home/blue/.m2/repository/org/apache/pdfbox/fontbox/1.8.4/fontbox-1.8.4.jar:/home/blue/.m2/repository/rome/rome/0.9/rome-0.9.jar:/home/blue/.m2/repository/commons-logging/commons-logging/1.1.1/commons-logging-1.1.1.jar:/home/blue/.m2/repository/com/google/code/findbugs/jsr305/2.0.1/jsr305-2.0.1.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-yarn-server-web-proxy/2.6.0-cdh5.4.2/hadoop-yarn-server-web-proxy-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/antlr/antlr/3.4/antlr-3.4.jar:/home/blue/.m2/repository/org/glassfish/javax.servlet/3.1/javax.servlet-3.1.jar:/home/blue/.m2/repository/org/ow2/asm/asm-debug-all/4.1/asm-debug-all-4.1.jar:/home/blue/.m2/repository/org/codehaus/jackson/jackson-xc/1.9.13/jackson-xc-1.9.13.jar:/home/blue/.m2/repository/postgresql/postgresql/9.0-801.jdbc4/postgresql-9.0-801.jdbc4.jar:/home/blue/.m2/repository/com/codahale/metrics/metrics-jvm/3.0.2/metrics-jvm-3.0.2.jar:/home/blue/.m2/repository/com/amazonaws/aws-java-sdk/1.7.4/aws-java-sdk-1.7.4.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-useragent/1.1.0/kite-morphlines-useragent-1.1.0.jar:/home/blue/.m2/repository/org/apache/derby/derby/10.11.1.1/derby-10.11.1.1.jar:/home/blue/.m2/repository/org/codehaus/groovy/groovy-all/2.1.6/groovy-all-2.1.6.jar:/home/blue/.m2/repository/com/yammer/metrics/metrics-core/2.2.0/metrics-core-2.2.0.jar:/home/blue/.m2/repository/org/glassfish/grizzly/grizzly-framework/2.1.2/grizzly-framework-2.1.2.jar:/home/blue/.m2/repository/org/mockito/mockito-all/1.8.5/mockito-all-1.8.5.jar:/home/blue/.m2/repository/org/apache/ivy/ivy/2.4.0/ivy-2.4.0.jar:/home/blue/.m2/repository/commons-beanutils/commons-beanutils/1.7.0/commons-beanutils-1.7.0.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-yarn-api/2.6.0-cdh5.4.2/hadoop-yarn-api-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-http/8.1.14.v20131031/jetty-http-8.1.14.v20131031.jar:/home/blue/.m2/repository/com/google/code/findbugs/annotations/2.0.1/annotations-2.0.1.jar:/home/blue/.m2/repository/org/apache/maven/maven-artifact/2.0.6/maven-artifact-2.0.6.jar:/home/blue/.m2/repository/org/codehaus/jackson/jackson-mapper-asl/1.9.13/jackson-mapper-asl-1.9.13.jar:/home/blue/.m2/repository/org/apache/curator/curator-x-discovery/2.5.0/curator-x-discovery-2.5.0.jar:/home/blue/.m2/repository/org/kitesdk/kite-data-crunch/1.1.0/kite-data-crunch-1.1.0.jar:/home/blue/.m2/repository/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar:/home/blue/.m2/repository/commons-digester/commons-digester/1.8/commons-digester-1.8.jar:/home/blue/.m2/repository/org/apache/hive/shims/hive-shims-common/1.1.0-cdh5.4.2/hive-shims-common-1.1.0-cdh5.4.2.jar:/home/blue/.m2/repository/commons-cli/commons-cli/1.2/commons-cli-1.2.jar:/home/blue/.m2/repository/org/glassfish/gmbal/gmbal-api-only/3.0.0-b023/gmbal-api-only-3.0.0-b023.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-auth/2.6.0-cdh5.4.2/hadoop-auth-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/com/twitter/parquet-jackson/1.6.0/parquet-jackson-1.6.0.jar:/home/blue/.m2/repository/org/javassist/javassist/3.16.1-GA/javassist-3.16.1-GA.jar:/home/blue/.m2/repository/org/sonatype/aether/aether-api/1.7/aether-api-1.7.jar:/usr/lib/jvm/java-7-oracle/jre/../lib/tools.jar:/home/blue/.m2/repository/org/apache/hive/hive-ant/1.1.0-cdh5.4.2/hive-ant-1.1.0-cdh5.4.2.jar:/home/blue/.m2/repository/com/codahale/metrics/metrics-core/3.0.2/metrics-core-3.0.2.jar:/home/blue/.m2/repository/com/fasterxml/jackson/core/jackson-databind/2.3.1/jackson-databind-2.3.1.jar:/home/blue/.m2/repository/org/apache/commons/commons-jexl/2.1.1/commons-jexl-2.1.1.jar:/home/blue/.m2/repository/net/sf/jpam/jpam/1.1/jpam-1.1.jar:/home/blue/.m2/repository/org/apache/openjpa/openjpa-lib/2.2.2/openjpa-lib-2.2.2.jar:/home/blue/.m2/repository/io/dropwizard/metrics/metrics-core/3.1.0/metrics-core-3.1.0.jar:/home/blue/.m2/repository/org/codehaus/janino/janino/2.7.6/janino-2.7.6.jar:/home/blue/.m2/repository/xml-apis/xml-apis/1.4.01/xml-apis-1.4.01.jar:/home/blue/.m2/repository/org/antlr/stringtemplate/3.2.1/stringtemplate-3.2.1.jar:/home/blue/.m2/repository/com/twitter/parquet-generator/1.6.0/parquet-generator-1.6.0.jar:/home/blue/.m2/repository/com/sun/jersey/jersey-json/1.9/jersey-json-1.9.jar:/home/blue/.m2/repository/commons-net/commons-net/3.1/commons-net-3.1.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-hadoop-compat/1.0.0-cdh5.4.2/hbase-hadoop-compat-1.0.0-cdh5.4.2-tests.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-hs/2.6.0-cdh5.4.2/hadoop-mapreduce-client-hs-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/ow2/asm/asm/4.1/asm-4.1.jar:/home/blue/.m2/repository/io/dropwizard/metrics/metrics-jvm/3.1.0/metrics-jvm-3.1.0.jar:/home/blue/.m2/repository/org/apache/hive/hcatalog/hive-hcatalog-core/0.13.1/hive-hcatalog-core-0.13.1.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-common/1.0.0-cdh5.4.2/hbase-common-1.0.0-cdh5.4.2.jar:/home/blue/.m2/repository/ua_parser/ua-parser/1.3.0/ua-parser-1.3.0.jar:/home/blue/.m2/repository/org/codehaus/plexus/plexus-utils/3.0/plexus-utils-3.0.jar:/home/blue/.m2/repository/antlr/antlr/2.7.7/antlr-2.7.7.jar:/home/blue/.m2/repository/commons-configuration/commons-configuration/1.6/commons-configuration-1.6.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-tika-decompress/1.1.0/kite-morphlines-tika-decompress-1.1.0.jar:/home/blue/.m2/repository/com/codahale/metrics/metrics-json/3.0.2/metrics-json-3.0.2.jar:/home/blue/.m2/repository/org/ccil/cowan/tagsoup/tagsoup/1.2.1/tagsoup-1.2.1.jar:/home/blue/.m2/repository/com/twitter/parquet-column/1.6.0/parquet-column-1.6.0.jar:/home/blue/.m2/repository/org/apache/hbase/hbase/0.94.6-cdh4.4.0/hbase-0.94.6-cdh4.4.0-tests.jar:/home/blue/.m2/repository/com/googlecode/javaewah/JavaEWAH/0.7.9/JavaEWAH-0.7.9.jar:/home/blue/.m2/repository/org/apache/hive/shims/hive-shims-common-secure/0.13.0/hive-shims-common-secure-0.13.0.jar:/home/blue/.m2/repository/org/apache/maven/maven-repository-metadata/2.0.6/maven-repository-metadata-2.0.6.jar:/home/blue/.m2/repository/org/apache/james/apache-mime4j-dom/0.7.2/apache-mime4j-dom-0.7.2.jar:/home/blue/.m2/repository/org/apache/httpcomponents/httpclient/4.3.1/httpclient-4.3.1.jar:/home/blue/.m2/repository/eigenbase/eigenbase-properties/1.1.4/eigenbase-properties-1.1.4.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-jobclient/2.6.0-cdh5.4.2/hadoop-mapreduce-client-jobclient-2.6.0-cdh5.4.2-tests.jar:/home/blue/.m2/repository/org/apache/hive/hive-serde/1.1.0-cdh5.4.2/hive-serde-1.1.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-spatial/4.10.3/lucene-spatial-4.10.3.jar:/home/blue/.m2/repository/org/apache/velocity/velocity/1.7/velocity-1.7.jar:/home/blue/.m2/repository/aopalliance/aopalliance/1.0/aopalliance-1.0.jar:/home/blue/.m2/repository/com/jolbox/bonecp/0.8.0.RELEASE/bonecp-0.8.0.RELEASE.jar:/home/blue/.m2/repository/joda-time/joda-time/2.3/joda-time-2.3.jar:/home/blue/.m2/repository/jdom/jdom/1.0/jdom-1.0.jar:/home/blue/.m2/repository/javax/xml/bind/jaxb-api/2.2.2/jaxb-api-2.2.2.jar:/home/blue/.m2/repository/net/sourceforge/serp/serp/1.14.1/serp-1.14.1.jar:/home/blue/.m2/repository/com/sun/jersey/jersey-core/1.9/jersey-core-1.9.jar:/home/blue/.m2/repository/org/apache/poi/poi-scratchpad/3.10.1/poi-scratchpad-3.10.1.jar:/home/blue/.m2/repository/org/xerial/snappy/snappy-java/1.1.1.6/snappy-java-1.1.1.6.jar:/home/blue/.m2/repository/commons-daemon/commons-daemon/1.0.13/commons-daemon-1.0.13.jar:/home/blue/.m2/repository/dom4j/dom4j/1.6.1/dom4j-1.6.1.jar:/home/blue/.m2/repository/org/tachyonproject/tachyon-client/0.5.0/tachyon-client-0.5.0.jar:/home/blue/.m2/repository/com/google/guava/guava/14.0.1/guava-14.0.1.jar:/home/blue/.m2/repository/org/apache/commons/commons-math3/3.1.1/commons-math3-3.1.1.jar:/home/blue/.m2/repository/javax/activation/activation/1.1/activation-1.1.jar:/home/blue/.m2/repository/org/apache/oozie/oozie-hadoop-utils/1.1.1.oozie-4.1.0/oozie-hadoop-utils-1.1.1.oozie-4.1.0.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-hadoop-compat/1.0.0-cdh5.4.2/hbase-hadoop-compat-1.0.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/json4s/json4s-ast_2.10/3.2.10/json4s-ast_2.10-3.2.10.jar:/home/blue/.m2/repository/com/adobe/xmp/xmpcore/5.1.2/xmpcore-5.1.2.jar:/home/blue/.m2/repository/org/codehaus/jettison/jettison/1.1/jettison-1.1.jar:/home/blue/.m2/repository/org/apache/hive/hcatalog/hive-webhcat-java-client/0.13.1/hive-webhcat-java-client-0.13.1.jar:/home/blue/.m2/repository/net/sf/saxon/Saxon-HE/9.5.1-5/Saxon-HE-9.5.1-5.jar:/home/blue/.m2/repository/com/google/protobuf/protobuf-java/2.5.0/protobuf-java-2.5.0.jar:/home/blue/.m2/repository/com/sun/jersey/jersey-server/1.14/jersey-server-1.14.jar:/home/blue/.m2/repository/org/antlr/antlr-runtime/3.5/antlr-runtime-3.5.jar:/home/blue/.m2/repository/com/twitter/parquet-common/1.6.0/parquet-common-1.6.0.jar:/home/blue/.m2/repository/org/apache/oozie/oozie-sharelib-oozie/4.1.0/oozie-sharelib-oozie-4.1.0.jar:/home/blue/.m2/repository/org/slf4j/slf4j-simple/1.6.1/slf4j-simple-1.6.1.jar:/home/blue/.m2/repository/org/slf4j/jul-to-slf4j/1.7.5/jul-to-slf4j-1.7.5.jar:/home/blue/.m2/repository/com/typesafe/config/1.0.2/config-1.0.2.jar:/home/blue/.m2/repository/org/uncommons/maths/uncommons-maths/1.2.2a/uncommons-maths-1.2.2a.jar:/home/blue/.m2/repository/org/apache/oozie/oozie-sharelib-hcatalog/4.1.0/oozie-sharelib-hcatalog-4.1.0.jar:/home/blue/.m2/repository/org/apache/flume/flume-ng-sinks/flume-irc-sink/1.5.0-cdh5.4.2/flume-irc-sink-1.5.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/eclipse/jdt/core/3.1.1/core-3.1.1.jar:/home/blue/.m2/repository/com/esotericsoftware/reflectasm/reflectasm/1.07/reflectasm-1.07-shaded.jar:/home/blue/.m2/repository/log4j/log4j/1.2.16/log4j-1.2.16.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-webapp/8.1.14.v20131031/jetty-webapp-8.1.14.v20131031.jar:/home/blue/.m2/repository/org/codehaus/plexus/plexus-classworlds/2.2.3/plexus-classworlds-2.2.3.jar:/home/blue/.m2/repository/org/apache/ftpserver/ftpserver-deprecated/1.0.0-M2/ftpserver-deprecated-1.0.0-M2.jar:/home/blue/.m2/repository/org/scala-lang/scala-compiler/2.10.0/scala-compiler-2.10.0.jar:/home/blue/.m2/repository/com/sun/jersey/jersey-test-framework/jersey-test-framework-core/1.9/jersey-test-framework-core-1.9.jar:/home/blue/.m2/repository/org/quartz-scheduler/quartz/2.1.7/quartz-2.1.7.jar:/home/blue/.m2/repository/net/sf/ehcache/ehcache-core/2.6.3/ehcache-core-2.6.3.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-aws/2.6.0-cdh5.4.2/hadoop-aws-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/kitesdk/kite-data-mapreduce/1.1.0/kite-data-mapreduce-1.1.0.jar:/home/blue/.m2/repository/org/slf4j/jcl-over-slf4j/1.7.5/jcl-over-slf4j-1.7.5.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-yarn-server-resourcemanager/2.6.0-cdh5.4.2/hadoop-yarn-server-resourcemanager-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/curator/curator-recipes/2.7.1/curator-recipes-2.7.1.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-core/4.10.3/lucene-core-4.10.3.jar:/home/blue/.m2/repository/com/jamesmurty/utils/java-xmlbuilder/0.4/java-xmlbuilder-0.4.jar:/home/blue/.m2/repository/com/esotericsoftware/kryo/kryo/2.21/kryo-2.21.jar:/home/blue/.m2/repository/org/apache/pdfbox/jempbox/1.8.4/jempbox-1.8.4.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-solr-core/1.1.0/kite-morphlines-solr-core-1.1.0.jar:/home/blue/.m2/repository/org/apache/avro/trevni-core/1.7.4/trevni-core-1.7.4.jar:/home/blue/.m2/repository/org/eclipse/jgit/org.eclipse.jgit/3.3.1.201403241930-r/org.eclipse.jgit-3.3.1.201403241930-r.jar:/home/blue/.m2/repository/org/kitesdk/kite-hadoop-compatibility/1.1.0/kite-hadoop-compatibility-1.1.0.jar:/home/blue/.m2/repository/ant/ant/1.6.5/ant-1.6.5.jar:/home/blue/.m2/repository/io/dropwizard/metrics/metrics-json/3.1.0/metrics-json-3.1.0.jar:/home/blue/.m2/repository/org/apache/flume/flume-ng-sinks/flume-hdfs-sink/1.5.0-cdh5.4.2/flume-hdfs-sink-1.5.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/flume/flume-ng-configuration/1.4.0/flume-ng-configuration-1.4.0.jar:/home/blue/.m2/repository/com/googlecode/mp4parser/isoparser/1.0-RC-1/isoparser-1.0-RC-1.jar:/home/blue/.m2/repository/org/mapdb/mapdb/0.9.9/mapdb-0.9.9.jar:/home/blue/.m2/repository/org/objenesis/objenesis/1.2/objenesis-1.2.jar:/home/blue/.m2/repository/org/apache/hive/hive-service/1.1.0-cdh5.4.2/hive-service-1.1.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/scala-lang/scala-reflect/2.10.0/scala-reflect-2.10.0.jar:/home/blue/.m2/repository/org/pentaho/pentaho-aggdesigner-algorithm/5.1.5-jhyde/pentaho-aggdesigner-algorithm-5.1.5-jhyde.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-memory/4.10.3/lucene-memory-4.10.3.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-jobclient/2.6.0-cdh5.4.2/hadoop-mapreduce-client-jobclient-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/tomcat/jasper-runtime/5.5.23/jasper-runtime-5.5.23.jar:/home/blue/.m2/repository/org/apache/xmlbeans/xmlbeans/2.6.0/xmlbeans-2.6.0.jar:/home/blue/.m2/repository/net/sf/jung/jung-api/2.0.1/jung-api-2.0.1.jar:/home/blue/.m2/repository/commons-logging/commons-logging-api/1.1/commons-logging-api-1.1.jar:/home/blue/.m2/repository/org/codehaus/woodstox/wstx-asl/3.2.7/wstx-asl-3.2.7.jar:/home/blue/.m2/repository/org/kitesdk/kite-data-s3/1.1.0/kite-data-s3-1.1.0.jar:/home/blue/.m2/repository/org/apache/geronimo/specs/geronimo-jaspic_1.0_spec/1.0/geronimo-jaspic_1.0_spec-1.0.jar:/home/blue/.m2/repository/org/eclipse/jetty/orbit/javax.activation/1.1.0.v201105071233/javax.activation-1.1.0.v201105071233.jar:/home/blue/.m2/repository/hsqldb/hsqldb/1.8.0.10/hsqldb-1.8.0.10.jar:/home/blue/.m2/repository/org/apache/maven/maven-settings-builder/3.0/maven-settings-builder-3.0.jar:/home/blue/.m2/repository/org/apache/geronimo/specs/geronimo-jta_1.1_spec/1.1.1/geronimo-jta_1.1_spec-1.1.1.jar:/home/blue/.m2/repository/org/json/json/20090211/json-20090211.jar:/home/blue/.m2/repository/org/apache/ant/ant-launcher/1.9.1/ant-launcher-1.9.1.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-mapreduce-client-core/2.6.0-cdh5.4.2/hadoop-mapreduce-client-core-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/sonatype/aether/aether-util/1.7/aether-util-1.7.jar:/home/blue/.m2/repository/org/ow2/asm/asm-commons/4.1/asm-commons-4.1.jar:/home/blue/.m2/repository/tomcat/jasper-compiler/5.5.23/jasper-compiler-5.5.23.jar:/home/blue/.m2/repository/org/codehaus/plexus/plexus-component-annotations/1.5.5/plexus-component-annotations-1.5.5.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-avro/1.1.0/kite-morphlines-avro-1.1.0.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-hdfs/2.6.0-cdh5.4.2/hadoop-hdfs-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/spark/spark-network-common_2.10/1.3.0-cdh5.4.2/spark-network-common_2.10-1.3.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/datanucleus/datanucleus-api-jdo/3.2.6/datanucleus-api-jdo-3.2.6.jar:/home/blue/.m2/repository/org/apache/directory/api/api-asn1-api/1.0.0-M20/api-asn1-api-1.0.0-M20.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-minicluster/2.6.0-mr1-cdh5.4.2/hadoop-minicluster-2.6.0-mr1-cdh5.4.2.jar:/home/blue/.m2/repository/org/glassfish/grizzly/grizzly-http-servlet/2.1.2/grizzly-http-servlet-2.1.2.jar:/home/blue/.m2/repository/javax/mail/mail/1.4.1/mail-1.4.1.jar:/home/blue/.m2/repository/org/datanucleus/datanucleus-rdbms/3.2.9/datanucleus-rdbms-3.2.9.jar:/home/blue/.m2/repository/org/kitesdk/kite-data-core/1.1.0/kite-data-core-1.1.0.jar:/home/blue/.m2/repository/commons-httpclient/commons-httpclient/3.1/commons-httpclient-3.1.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-annotations/2.6.0-cdh5.4.2/hadoop-annotations-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/colt/colt/1.2.0/colt-1.2.0.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-analyzers-kuromoji/4.10.3/lucene-analyzers-kuromoji-4.10.3.jar:/home/blue/.m2/repository/org/apache/spark/spark-network-shuffle_2.10/1.3.0-cdh5.4.2/spark-network-shuffle_2.10-1.3.0-cdh5.4.2.jar:/home/blue/.m2/repository/com/codahale/metrics/metrics-graphite/3.0.0/metrics-graphite-3.0.0.jar:/home/blue/.m2/repository/org/apache/openjpa/openjpa-persistence/2.2.2/openjpa-persistence-2.2.2.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-jndi/8.1.14.v20131031/jetty-jndi-8.1.14.v20131031.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-server/1.0.0-cdh5.4.2/hbase-server-1.0.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/ftpserver/ftpserver-core/1.0.0/ftpserver-core-1.0.0.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-join/4.10.3/lucene-join-4.10.3.jar:/home/blue/.m2/repository/org/sonatype/sisu/sisu-guice/2.1.7/sisu-guice-2.1.7-noaop.jar:/home/blue/.m2/repository/net/sf/opencsv/opencsv/2.3/opencsv-2.3.jar:/home/blue/.m2/repository/javax/servlet/jsp/jsp-api/2.1/jsp-api-2.1.jar:/home/blue/.m2/repository/javax/servlet/servlet-api/2.5/servlet-api-2.5.jar:/home/blue/.m2/repository/org/apache/openjpa/openjpa-kernel/2.2.2/openjpa-kernel-2.2.2.jar:/home/blue/.m2/repository/com/twitter/parquet-avro/1.6.0/parquet-avro-1.6.0.jar:/home/blue/.m2/repository/commons-dbcp/commons-dbcp/1.4/commons-dbcp-1.4.jar:/home/blue/.m2/repository/org/jruby/joni/joni/2.1.2/joni-2.1.2.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-common/1.0.0-cdh5.4.2/hbase-common-1.0.0-cdh5.4.2-tests.jar:/home/blue/.m2/repository/org/slf4j/slf4j-log4j12/1.7.5/slf4j-log4j12-1.7.5.jar:/home/blue/.m2/repository/com/twitter/chill_2.10/0.5.0/chill_2.10-0.5.0.jar:/home/blue/.m2/repository/org/apache/flume/flume-ng-channels/flume-jdbc-channel/1.5.0-cdh5.4.2/flume-jdbc-channel-1.5.0-cdh5.4.2.jar:/home/blue/.m2/repository/com/jcraft/jsch/0.1.50/jsch-0.1.50.jar:/home/blue/.m2/repository/org/apache/flume/flume-ng-sdk/1.4.0/flume-ng-sdk-1.4.0.jar:/home/blue/.m2/repository/org/apache/calcite/calcite-avatica/1.0.0-incubating/calcite-avatica-1.0.0-incubating.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-common/2.6.0-cdh5.4.2/hadoop-common-2.6.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/commons/commons-lang3/3.3.2/commons-lang3-3.3.2.jar:/home/blue/.m2/repository/org/apache/httpcomponents/httpcore/4.3/httpcore-4.3.jar:/home/blue/.m2/repository/org/apache/maven/maven-model-builder/3.0/maven-model-builder-3.0.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-core/1.1.0/kite-morphlines-core-1.1.0.jar:/home/blue/.m2/repository/org/apache/maven/maven-project/2.0.6/maven-project-2.0.6.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-saxon/1.1.0/kite-morphlines-saxon-1.1.0.jar:/home/blue/.m2/repository/org/kitesdk/kite-data-hbase/1.1.0/kite-data-hbase-1.1.0.jar:/home/blue/.m2/repository/org/kitesdk/kite-data-hive/1.1.0/kite-data-hive-1.1.0.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-annotations/1.0.0-cdh5.4.2/hbase-annotations-1.0.0-cdh5.4.2-tests.jar:/home/blue/.m2/repository/org/tukaani/xz/1.4/xz-1.4.jar:/home/blue/.m2/repository/net/sf/jung/jung-algorithms/2.0.1/jung-algorithms-2.0.1.jar:/home/blue/.m2/repository/org/mortbay/jetty/servlet-api-2.5/6.1.14/servlet-api-2.5-6.1.14.jar:/home/blue/.m2/repository/org/spark-project/protobuf/protobuf-java/2.4.1-shaded/protobuf-java-2.4.1-shaded.jar:/home/blue/.m2/repository/com/maxmind/db/maxmind-db/1.0.0/maxmind-db-1.0.0.jar:/home/blue/.m2/repository/com/twitter/parquet-hadoop/1.6.0/parquet-hadoop-1.6.0.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-highlighter/4.10.3/lucene-highlighter-4.10.3.jar:/home/blue/.m2/repository/org/apache/maven/maven-artifact-manager/2.0.6/maven-artifact-manager-2.0.6.jar:/home/blue/.m2/repository/org/tachyonproject/tachyon/0.5.0/tachyon-0.5.0.jar:/home/blue/.m2/repository/org/codehaus/plexus/plexus-interpolation/1.14/plexus-interpolation-1.14.jar:/home/blue/.m2/repository/org/apache/directory/server/apacheds-kerberos-codec/2.0.0-M15/apacheds-kerberos-codec-2.0.0-M15.jar:/home/blue/.m2/repository/io/netty/netty/3.6.6.Final/netty-3.6.6.Final.jar:/home/blue/.m2/repository/org/sonatype/sisu/sisu-inject-plexus/1.4.2/sisu-inject-plexus-1.4.2.jar:/home/blue/.m2/repository/log4j/apache-log4j-extras/1.2.17/apache-log4j-extras-1.2.17.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-analyzers-phonetic/4.10.3/lucene-analyzers-phonetic-4.10.3.jar:/home/blue/.m2/repository/com/drewnoakes/metadata-extractor/2.6.2/metadata-extractor-2.6.2.jar:/home/blue/.m2/repository/javax/jdo/jdo-api/3.0.1/jdo-api-3.0.1.jar:/home/blue/.m2/repository/org/apache/hive/hive-common/1.1.0-cdh5.4.2/hive-common-1.1.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/aspectj/aspectjrt/1.6.11/aspectjrt-1.6.11.jar:/home/blue/.m2/repository/org/apache/james/apache-mime4j-core/0.7.2/apache-mime4j-core-0.7.2.jar:/home/blue/.m2/repository/com/sun/jersey/jersey-grizzly2/1.9/jersey-grizzly2-1.9.jar:/home/blue/.m2/repository/org/mortbay/jetty/servlet-api/2.5-20081211/servlet-api-2.5-20081211.jar:/home/blue/.m2/repository/org/spark-project/spark/unused/1.0.0/unused-1.0.0.jar:/home/blue/.m2/repository/org/apache/avro/avro-ipc/1.7.5/avro-ipc-1.7.5.jar:/home/blue/.m2/repository/net/java/dev/jets3t/jets3t/0.9.0/jets3t-0.9.0.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-hadoop2-compat/1.0.0-cdh5.4.2/hbase-hadoop2-compat-1.0.0-cdh5.4.2-tests.jar:/home/blue/.m2/repository/org/spark-project/pyrolite/2.0.1/pyrolite-2.0.1.jar:/home/blue/.m2/repository/io/dropwizard/metrics/metrics-graphite/3.1.0/metrics-graphite-3.1.0.jar:/home/blue/.m2/repository/com/sun/jersey/jersey-test-framework/jersey-test-framework-grizzly2/1.9/jersey-test-framework-grizzly2-1.9.jar:/home/blue/.m2/repository/xmlenc/xmlenc/0.52/xmlenc-0.52.jar:/home/blue/.m2/repository/org/spark-project/akka/akka-slf4j_2.10/2.2.3-shaded-protobuf/akka-slf4j_2.10-2.2.3-shaded-protobuf.jar:/home/blue/.m2/repository/com/twitter/chill-java/0.5.0/chill-java-0.5.0.jar:/home/blue/.m2/repository/org/apache/hive/shims/hive-shims-scheduler/1.1.0-cdh5.4.2/hive-shims-scheduler-1.1.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/apache/hive/shims/hive-shims-0.20S/0.13.0/hive-shims-0.20S-0.13.0.jar:/home/blue/.m2/repository/org/restlet/jee/org.restlet/2.1.1/org.restlet-2.1.1.jar:/home/blue/.m2/repository/net/sf/py4j/py4j/0.8.2.1/py4j-0.8.2.1.jar:/home/blue/.m2/repository/org/apache/openjpa/openjpa-jdbc/2.2.2/openjpa-jdbc-2.2.2.jar:/home/blue/.m2/repository/org/apache/curator/curator-client/2.7.1/curator-client-2.7.1.jar:/home/blue/.m2/repository/org/mortbay/jetty/jetty-util/6.1.26.cloudera.4/jetty-util-6.1.26.cloudera.4.jar:/home/blue/.m2/repository/org/apache/hive/hcatalog/hive-hcatalog-server-extensions/0.13.1/hive-hcatalog-server-extensions-0.13.1.jar:/home/blue/.m2/repository/org/slf4j/slf4j-api/1.6.1/slf4j-api-1.6.1.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-yarn-server-tests/2.6.0-cdh5.4.2/hadoop-yarn-server-tests-2.6.0-cdh5.4.2-tests.jar:/home/blue/.m2/repository/org/twdata/maven/mojo-executor/1.5/mojo-executor-1.5.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-hdfs/2.6.0-cdh5.4.2/hadoop-hdfs-2.6.0-cdh5.4.2-tests.jar:/home/blue/.m2/repository/org/apache/flume/flume-ng-core/1.4.0/flume-ng-core-1.4.0.jar:/home/blue/.m2/repository/org/yaml/snakeyaml/1.10/snakeyaml-1.10.jar:/home/blue/.m2/repository/net/sf/jung/jung-visualization/2.0.1/jung-visualization-2.0.1.jar:/home/blue/.m2/repository/org/apache/hadoop/hadoop-common/2.6.0-cdh5.4.2/hadoop-common-2.6.0-cdh5.4.2-tests.jar:/home/blue/.m2/repository/org/apache/openjpa/openjpa-persistence-jdbc/2.2.2/openjpa-persistence-jdbc-2.2.2.jar:/home/blue/.m2/repository/org/apache/hive/hive-metastore/1.1.0-cdh5.4.2/hive-metastore-1.1.0-cdh5.4.2.jar:/home/blue/.m2/repository/com/thoughtworks/paranamer/paranamer/2.3/paranamer-2.3.jar:/home/blue/.m2/repository/com/googlecode/json-simple/json-simple/1.1/json-simple-1.1.jar:/home/blue/.m2/repository/com/twitter/parquet-hadoop-bundle/1.5.0-cdh5.4.2/parquet-hadoop-bundle-1.5.0-cdh5.4.2.jar:/home/blue/.m2/repository/edu/ucar/netcdf/4.2-min/netcdf-4.2-min.jar:/home/blue/.m2/repository/org/apache/lucene/lucene-queries/4.10.3/lucene-queries-4.10.3.jar:/home/blue/.m2/repository/org/mortbay/jetty/jsp-api-2.1/6.1.14/jsp-api-2.1-6.1.14.jar:/home/blue/.m2/repository/com/fasterxml/jackson/module/jackson-module-scala_2.10/2.2.3/jackson-module-scala_2.10-2.2.3.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-metrics-servlets/1.1.0/kite-morphlines-metrics-servlets-1.1.0.jar:/home/blue/.m2/repository/io/netty/netty-all/4.0.23.Final/netty-all-4.0.23.Final.jar:/home/blue/.m2/repository/org/sonatype/plexus/plexus-cipher/1.4/plexus-cipher-1.4.jar:/home/blue/.m2/repository/org/apache/oozie/oozie-client/3.3.2-cdh4.4.0/oozie-client-3.3.2-cdh4.4.0.jar:/home/blue/.m2/repository/org/codehaus/janino/commons-compiler/2.7.6/commons-compiler-2.7.6.jar:/home/blue/.m2/repository/org/kitesdk/kite-morphlines-hadoop-parquet-avro/1.1.0/kite-morphlines-hadoop-parquet-avro-1.1.0.jar:/home/blue/.m2/repository/org/eclipse/jetty/jetty-servlet/8.1.14.v20131031/jetty-servlet-8.1.14.v20131031.jar:/home/blue/.m2/repository/javax/inject/javax.inject/1/javax.inject-1.jar:/home/blue/.m2/repository/net/sf/jung/jung-graph-impl/2.0.1/jung-graph-impl-2.0.1.jar:/home/blue/.m2/repository/org/apache/crunch/crunch-core/0.11.0-cdh5.4.2/crunch-core-0.11.0-cdh5.4.2.jar:/home/blue/.m2/repository/com/fasterxml/jackson/core/jackson-core/2.3.1/jackson-core-2.3.1.jar:/home/blue/.m2/repository/com/ning/compress-lzf/1.0.0/compress-lzf-1.0.0.jar:/home/blue/.m2/repository/asm/asm/3.2/asm-3.2.jar:/home/blue/.m2/repository/org/apache/hbase/hbase-protocol/1.0.0-cdh5.4.2/hbase-protocol-1.0.0-cdh5.4.2.jar:/home/blue/.m2/repository/org/jdom/jdom/1.1/jdom-1.1.jar -encoding UTF-8 -overview /home/blue/workspace/kite/src/main/javadoc/overview.html -protected -sourcepath /home/blue/workspace/kite/src/main/javadoc:/home/blue/workspace/kite/kite-hadoop-compatibility/src/main/java:/home/blue/workspace/kite/kite-data/kite-data-core/src/main/java:/home/blue/workspace/kite/kite-data/kite-data-core/src/main/javadoc:/home/blue/workspace/kite/kite-data/kite-data-oozie/src/main/java:/home/blue/workspace/kite/kite-data/kite-data-hive/src/main/java:/home/blue/workspace/kite/kite-data/kite-data-s3/src/main/java:/home/blue/workspace/kite/kite-data/kite-data-hbase/src/main/java:/home/blue/workspace/kite/kite-data/kite-data-hbase/target/generated-sources/src/main/java:/home/blue/workspace/kite/kite-data/kite-data-hbase/target/generated-sources/src/test/java:/home/blue/workspace/kite/kite-data/kite-data-mapreduce/src/main/java:/home/blue/workspace/kite/kite-data/kite-data-crunch/src/main/java:/home/blue/workspace/kite/kite-data/kite-data-flume/src/main/java:/home/blue/workspace/kite/kite-maven-plugin/src/main/java:/home/blue/workspace/kite/kite-maven-plugin/target/generated-sources/plugin:/home/blue/workspace/kite/kite-tools-parent/kite-tools/src/main/java:/home/blue/workspace/kite/kite-tools-parent/kite-tools/target/generated-sources/avro:/home/blue/workspace/kite/kite-minicluster/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-core/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-avro/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-json/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-maxmind/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-metrics-servlets/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-protobuf/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-saxon/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-tika-core/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-tika-decompress/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-twitter/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-hadoop-core/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-hadoop-parquet-avro/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-hadoop-rcfile/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-hadoop-sequencefile/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-useragent/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-solr-core/src/main/java:/home/blue/workspace/kite/kite-morphlines/kite-morphlines-solr-cell/src/main/java -apiname Kite SDK 1.1.0 -->
<package name="org.kitesdk.data">
  <!-- start class org.kitesdk.data.ColumnMapping -->
  <class name="ColumnMapping" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getFieldMappings" return="java.util.Collection&lt;org.kitesdk.data.FieldMapping&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFieldMapping" return="org.kitesdk.data.FieldMapping"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldName" type="java.lang.String"/>
    </method>
    <method name="getRequiredColumns" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the columns required by this schema.

 @return The set of columns]]>
      </doc>
    </method>
    <method name="getRequiredColumnFamilies" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the column families required by this schema.

 @return The set of column families.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pretty" type="boolean"/>
    </method>
    <doc>
    <![CDATA[A descriptor for an entity's column mappings, which defines how an entity
 maps to a columnar store.

 @since 0.14.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.ColumnMapping -->
  <!-- start class org.kitesdk.data.ColumnMapping.Builder -->
  <class name="ColumnMapping.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ColumnMapping.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="key" return="org.kitesdk.data.ColumnMapping.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a mapping to store the record field {@code name} in the record key.

 The underlying dataset's {@link PartitionStrategy} must have an identity
 partitioner for the record field {@code name} so that the value can be
 recovered.

 @param name The name of a record field
 @return This Builder for method chaining]]>
      </doc>
    </method>
    <method name="column" return="org.kitesdk.data.ColumnMapping.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="family" type="java.lang.String"/>
      <param name="qualifier" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a mapping to store the record field {@code name} in a column using
 the {@code family} and {@code qualifier}.

 @param name The name of a record field
 @param family The column family for storing the record field value
 @param qualifier The column qualifier for storing the record field value
 @return This Builder for method chaining]]>
      </doc>
    </method>
    <method name="keyAsColumn" return="org.kitesdk.data.ColumnMapping.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="family" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a key-as-column mapping to store the record field {@code name} in
 the given {@code family}, using its keys or fields as column qualifiers.

 The record field must be a map or a record.

 @param name The name of a record field
 @param family The column family for storing the map or record values
 @return This Builder for method chaining]]>
      </doc>
    </method>
    <method name="keyAsColumn" return="org.kitesdk.data.ColumnMapping.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="family" type="java.lang.String"/>
      <param name="qualifierPrefix" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a key-as-column mapping to store the record field {@code name} in
 the given {@code family}, using column qualifiers built from its keys or
 field names appended to the {@code qualifierPrefix}.

 The record field must be a map or a record.

 @param name The name of a record field
 @param family The column family for storing the map or record values
 @param qualifierPrefix A prefix to add when building column qualifiers
 @return This Builder for method chaining]]>
      </doc>
    </method>
    <method name="counter" return="org.kitesdk.data.ColumnMapping.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="family" type="java.lang.String"/>
      <param name="qualifier" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds a counter mapping to store record field {@code name} in a column
 using the {@code family} and {@code qualifier}. The record field can be
 updated atomically using
 {@link RandomAccessDataset#increment(Key, String, long)}

 The record field must be an int or a long.

 Counters cannot be used in combination with optimistic concurrency (OCC).

 @param name The name of a record field
 @param family The column family for storing the record counter value
 @param qualifier The column qualifier for storing the record field value
 @return This Builder for method chaining]]>
      </doc>
    </method>
    <method name="occ" return="org.kitesdk.data.ColumnMapping.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds an OCC version mapping for the record field {@code name}. The
 record field will contain the current version number of the record.

 Using this mapping enables optimistic concurrency (OCC), where the
 underlying {@link RandomAccessDataset} will only persist changes to a
 record if it has not changed by another process.

 The record field must be an int or a long.

 Optimistic concurrency (OCC) cannot be used in combination with counters.

 @param name The name of a record field to use for an OCC version
 @return This Builder for method chaining]]>
      </doc>
    </method>
    <method name="version" return="org.kitesdk.data.ColumnMapping.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds an OCC version mapping for the record field {@code name}. The
 record field will contain the current version number of the record.

 Using this mapping enables optimistic concurrency (OCC), where the
 underlying {@link RandomAccessDataset} will only persist changes to a
 record if it has not changed by another process.

 The record field must be an int or a long.

 Optimistic concurrency (OCC) cannot be used in combination with counters.

 @param name The name of a record field to use for an OCC version
 @return This Builder for method chaining]]>
      </doc>
    </method>
    <method name="fieldMapping" return="org.kitesdk.data.ColumnMapping.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldMapping" type="org.kitesdk.data.FieldMapping"/>
      <doc>
      <![CDATA[Adds a {@link FieldMapping}.

 @param fieldMapping A {@code FieldMapping}
 @return This Builder for method chaining]]>
      </doc>
    </method>
    <method name="fieldMappings" return="org.kitesdk.data.ColumnMapping.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="fieldMappings" type="java.util.Collection&lt;org.kitesdk.data.FieldMapping&gt;"/>
      <doc>
      <![CDATA[Adds each {@link FieldMapping} from a collection.

 @param fieldMappings A collection of {@code FieldMapping} objects
 @return This Builder for method chaining]]>
      </doc>
    </method>
    <method name="build" return="org.kitesdk.data.ColumnMapping"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Builds and returns a {@link ColumnMapping} from the fields
 mappings added to this builder.

 @return a ColumnMapping]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A fluent builder to aid in constructing a {@link ColumnMapping}.

 @since 0.14.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.ColumnMapping.Builder -->
  <!-- start class org.kitesdk.data.CompressionType -->
  <class name="CompressionType" extends="java.lang.Enum&lt;org.kitesdk.data.CompressionType&gt;"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.kitesdk.data.CompressionType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.kitesdk.data.CompressionType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@code String} name for this compression type. This name can be
 passed to {@link #forName(java.lang.String)} to return this instance.

 @return the name of the compression type]]>
      </doc>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="forName" return="org.kitesdk.data.CompressionType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Return a {@code CompressionType} for the compression type name specified.
 If {@code name} is not a valid name, an
 {@link IllegalArgumentException} is thrown. Current the compression types
 <q>snappy</q>, <q>deflate</q>, <q>bzip2</q>, and <q>lzo</q> are supported.
 Not all compression types are supported by all {@link Format}s.

 @param name the name of the compression type
 @return the appropriate CompressionType

 @throws IllegalArgumentException if {@code name} is not a valid compression type.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 Contains constant definitions for the standard compression types we support.
 Not every {@link Format} supports every compression type. Use
 {@link Format#getSupportedCompressionTypes()} to see what compression
 types your {@link Format} supports.
 </p>
 @since 0.17.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.CompressionType -->
  <!-- start class org.kitesdk.data.ConcurrentSchemaModificationException -->
  <class name="ConcurrentSchemaModificationException" extends="org.kitesdk.data.DatasetException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ConcurrentSchemaModificationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ConcurrentSchemaModificationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ConcurrentSchemaModificationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[<p>
 Exception thrown when a schema modification collides with
 another client trying to modify the schema of the same
 dataset.
 <p>
 @since 0.9.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.ConcurrentSchemaModificationException -->
  <!-- start interface org.kitesdk.data.Dataset -->
  <interface name="Dataset"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.data.RefinableView&lt;E&gt;"/>
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the name of a {@code Dataset}. No guarantees are made about the format
 of this name.]]>
      </doc>
    </method>
    <method name="getNamespace" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the namespace that contains this {@code Dataset}. A namespace is a
 string that identifies a logical group of datasets.

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="getDescriptor" return="org.kitesdk.data.DatasetDescriptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link DatasetDescriptor} associated with this dataset.]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Return a {@code URI} for this {@code Dataset}.

 The returned URI should load a copy of this dataset when passed to
 {@link Datasets#load(java.net.URI, java.lang.Class)}.

 @return a URI that identifies this dataset
 @since 0.15.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 A logical representation of a set of data entities.
 </p>
 <p>
 Logically, all datasets have two generic properties: a name, and a descriptor
 that holds information such as the dataset's schema and its partitioning
 information. Concrete implementations of {@code Dataset} can support
 additional properties, mandatory or otherwise, as needed. {@code Dataset}s
 are not normally instantiated directly, but managed by a repository (also
 implementation-specific).
 </p>
 <p>
 Implementations of {@link Dataset} are immutable.
 </p>

 @param <E> The type of entities stored in this {@code Dataset}.

 @see View
 @see DatasetWriter
 @see DatasetReader
 @see PartitionStrategy
 @see DatasetDescriptor
 @see Schema]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.data.Dataset -->
  <!-- start class org.kitesdk.data.DatasetDescriptor -->
  <class name="DatasetDescriptor" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetDescriptor" type="org.apache.avro.Schema, java.net.URL, org.kitesdk.data.Format, java.net.URI, java.util.Map&lt;java.lang.String, java.lang.String&gt;, org.kitesdk.data.PartitionStrategy"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance of this class with the supplied {@link Schema},
 optional URL, {@link Format}, optional location URL, and optional
 {@link PartitionStrategy}.]]>
      </doc>
    </constructor>
    <constructor name="DatasetDescriptor" type="org.apache.avro.Schema, java.net.URL, org.kitesdk.data.Format, java.net.URI, java.util.Map&lt;java.lang.String, java.lang.String&gt;, org.kitesdk.data.PartitionStrategy, org.kitesdk.data.ColumnMapping"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance of this class with the supplied {@link Schema}, optional
 URL, {@link Format}, optional location URL, optional
 {@link PartitionStrategy}, and optional {@link ColumnMapping}.

 @since 0.14.0]]>
      </doc>
    </constructor>
    <constructor name="DatasetDescriptor" type="org.apache.avro.Schema, java.net.URI, org.kitesdk.data.Format, java.net.URI, java.util.Map&lt;java.lang.String, java.lang.String&gt;, org.kitesdk.data.PartitionStrategy, org.kitesdk.data.ColumnMapping, org.kitesdk.data.CompressionType"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Create an instance of this class with the supplied {@link Schema}, optional
 URL, {@link Format}, optional location URL, optional
 {@link PartitionStrategy}, optional {@link ColumnMapping}, and optional
 {@link CompressionType}.

 @since 0.17.0]]>
      </doc>
    </constructor>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the associated {@link Schema}. Depending on the underlying storage
 system, this schema can be simple (that is, records made up of only scalar
 types) or complex (that is, containing other records, lists, and so on).
 Validation of the supported schemas is performed by the managing
 repository, not the dataset or descriptor itself.

 @return the schema]]>
      </doc>
    </method>
    <method name="getSchemaUrl" return="java.net.URL"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a URL from which the {@link Schema} can be retrieved (optional). This
 method might return {@code null} if the schema is not stored at a persistent
 URL (for example, if it were constructed from a literal string).

 @return a URL from which the schema can be retrieved
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="getFormat" return="org.kitesdk.data.Format"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the associated {@link Format} the data is stored in.

 @return the format
 @since 0.2.0]]>
      </doc>
    </method>
    <method name="getLocation" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the URL location where the data for this {@link Dataset} is stored
 (optional).

 @return a location URL or null if one is not set

 @since 0.8.0]]>
      </doc>
    </method>
    <method name="getProperty" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Get a named property.

 @param name the String property name to get.
 @return the String value of the property, or null if it does not exist.

 @since 0.8.0]]>
      </doc>
    </method>
    <method name="hasProperty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Check if a named property exists.

 @param name the String property name.
 @return true if the property exists, false otherwise.

 @since 0.8.0]]>
      </doc>
    </method>
    <method name="listProperties" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[List the names of all custom properties set.

 @return a Collection of String property names.

 @since 0.8.0]]>
      </doc>
    </method>
    <method name="getPartitionStrategy" return="org.kitesdk.data.PartitionStrategy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link PartitionStrategy}, if this dataset is partitioned. Calling
 this method on a non-partitioned dataset is an error. Instead, use the
 {@link #isPartitioned()} method prior to invocation.]]>
      </doc>
    </method>
    <method name="getColumnMapping" return="org.kitesdk.data.ColumnMapping"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link ColumnMapping}.

 @return ColumnMapping

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="getCompressionType" return="org.kitesdk.data.CompressionType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link CompressionType}

 @return the compression format

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="isPartitioned" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if an associated dataset is partitioned (that is, has an
 associated {@link PartitionStrategy}), false otherwise.]]>
      </doc>
    </method>
    <method name="isColumnMapped" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns true if an associated dataset is column mapped (that is, has an
 associated {@link ColumnMapping}), false otherwise.

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 The structural definition of a {@link Dataset}.
 </p>
 <p>
 Each {@code Dataset} has an associated {@link Schema} and optional
 {@link PartitionStrategy} defined at the time of creation. You use instances
 of this class to hold this information. You are strongly encouraged to use
 the inner {@link Builder} to create new instances.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.DatasetDescriptor -->
  <!-- start class org.kitesdk.data.DatasetDescriptor.Builder -->
  <class name="DatasetDescriptor.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetDescriptor.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetDescriptor.Builder" type="org.kitesdk.data.DatasetDescriptor"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a Builder configured to copy {@code descriptor}, if it is not
 modified. This is intended to help callers copy and update descriptors
 even though they are {@link Immutable}.

 @param descriptor A {@link DatasetDescriptor} to copy settings from
 @since 0.7.0]]>
      </doc>
    </constructor>
    <method name="schema" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.avro.Schema"/>
      <doc>
      <![CDATA[Configure the dataset's schema. A schema is required, and can be set
 using one of the methods: {@code schema}, {@code schemaLiteral},
 {@code schemaUri}, or {@code schemaFromAvroDataFile}.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="schema" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's schema from a {@link File}. A schema is required,
 and can be set using one of the methods {@code schema},
 {@code schemaLiteral}, {@code schemaUri}, or
 {@code schemaFromAvroDataFile}.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="schema" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's schema from an {@link InputStream}. It is the
 caller's responsibility to close the {@link InputStream}. A schema is
 required, and can be set using one of the methods {@code schema},
 {@code schemaLiteral}, {@code schemaUri}, or
 {@code schemaFromAvroDataFile}.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="schemaUri" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the {@link Dataset}'s schema from a URI. A schema is required,
 and can be set using one of the methods {@code schema},
 {@code schemaLiteral}, {@code schemaUri}, or
 {@code schemaFromAvroDataFile}.

 @param uri a URI object for the schema's location.
 @return An instance of the builder for method chaining.
 @throws IOException

 @since 0.8.0]]>
      </doc>
    </method>
    <method name="schemaUri" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the {@link Dataset}'s schema from a String URI. A schema is
 required, and can be set using one of the methods {@code schema},
 {@code schemaLiteral}, {@code schemaUri}, or
 {@code schemaFromAvroDataFile}.

 @param uri a String URI
 @return An instance of the builder for method chaining.
 @throws IOException

 @since 0.8.0]]>
      </doc>
    </method>
    <method name="schemaLiteral" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="s" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure the dataset's schema from a {@link String}. A schema is
 required, and can be set using one of the methods {@code schema},
 {@code schemaLiteral}, {@code schemaUri}, or
 {@code schemaFromAvroDataFile}.

 @return An instance of the builder for method chaining.

 @since 0.8.0]]>
      </doc>
    </method>
    <method name="schema" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Configure the dataset's schema via a Java class type. A schema is
 required, and can be set using one of the methods {@code schema},
 {@code schemaLiteral}, {@code schemaUri}, or
 {@code schemaFromAvroDataFile}.

 @return An instance of the builder for method chaining.
 @since 0.2.0]]>
      </doc>
    </method>
    <method name="schemaFromAvroDataFile" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's schema by using the schema from an existing Avro
 data file. A schema is required, and can be set using one of the methods
 {@code schema}, {@code schemaLiteral}, {@code schemaUri}, or
 {@code schemaFromAvroDataFile}.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="schemaFromAvroDataFile" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's schema by using the schema from an existing Avro
 data file. It is the caller's responsibility to close the
 {@link InputStream}. A schema is required, and can be set using one of
 the methods  {@code schema},  {@code schemaLiteral}, {@code schemaUri},
 or {@code schemaFromAvroDataFile}.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="schemaFromAvroDataFile" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's schema by using the schema from an existing Avro
 data file. A schema is required, and can be set using one of the methods
 {@code schema}, {@code schemaLiteral}, {@code schemaUri}, or
 {@code schemaFromAvroDataFile}.

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="format" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="format" type="org.kitesdk.data.Format"/>
      <doc>
      <![CDATA[Configure the dataset's format (optional). If not specified
 {@link Formats#AVRO} is used by default.

 @return An instance of the builder for method chaining.
 @since 0.2.0]]>
      </doc>
    </method>
    <method name="format" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="formatName" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure the dataset's format from a format name String (optional). If
 not specified, {@link Formats#AVRO} is used by default.

 @param formatName a String format name
 @return An instance of the builder for method chaining.
 @throws UnknownFormatException if the format name is not recognized.

 @since 0.8.0]]>
      </doc>
    </method>
    <method name="location" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Configure the dataset's location (optional).

 @param uri A URI location
 @return An instance of the builder for method chaining.

 @since 0.8.0]]>
      </doc>
    </method>
    <method name="location" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="org.apache.hadoop.fs.Path"/>
      <doc>
      <![CDATA[Configure the dataset's location (optional).

 @param uri A location Path
 @return An instance of the builder for method chaining.

 @since 0.8.0]]>
      </doc>
    </method>
    <method name="location" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure the dataset's location (optional).

 @param uri A location String URI
 @return An instance of the builder for method chaining.

 @since 0.8.0]]>
      </doc>
    </method>
    <method name="property" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Add a key-value property to the descriptor.

 @param name the property name
 @param value the property value
 @return An instance of the builder for method chaining.

 @since 0.8.0]]>
      </doc>
    </method>
    <method name="partitionStrategy" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="partitionStrategy" type="org.kitesdk.data.PartitionStrategy"/>
      <doc>
      <![CDATA[Configure the dataset's partitioning strategy (optional).

 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="partitionStrategy" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Configure the dataset's partition strategy from a File.

 The File contents must be a JSON-formatted partition strategy that is
 produced by {@link PartitionStrategy#toString()}.

 @param file
          The File
 @return
          An instance of the builder for method chaining.
 @throws ValidationException
          If the file does not contain a valid JSON-encoded partition
          strategy
 @throws DatasetIOException
          If there is an IOException accessing the file contents

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="partitionStrategy" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <doc>
      <![CDATA[Configure the dataset's partition strategy from an InputStream.

 The InputStream contents must be a JSON-formatted partition strategy
 that is produced by {@link PartitionStrategy#toString()}.

 @param in
          The input stream
 @return An instance of the builder for method chaining.
 @throws ValidationException
          If the stream does not contain a valid JSON-encoded partition
          strategy
 @throws DatasetIOException
          If there is an IOException accessing the InputStream contents

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="partitionStrategyLiteral" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="literal" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure the dataset's partition strategy from a String literal.

 The String literal is a JSON-formatted partition strategy that can be
 produced by {@link PartitionStrategy#toString()}.

 @param literal
          A partition strategy String literal
 @return This builder for method chaining.
 @throws ValidationException
          If the literal is not a valid JSON-encoded partition strategy

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="partitionStrategyUri" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's partition strategy from a URI.

 @param uri
          A URI to a partition strategy JSON file.
 @return This builder for method chaining.
 @throws ValidationException
          If the literal is not a valid JSON-encoded partition strategy

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="partitionStrategyUri" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's partition strategy from a String URI.

 @param uri
          A String URI to a partition strategy JSON file.
 @return This builder for method chaining.
 @throws ValidationException
          If the literal is not a valid JSON-encoded partition strategy

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="columnMapping" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="columnMappings" type="org.kitesdk.data.ColumnMapping"/>
      <doc>
      <![CDATA[Configure the dataset's column mapping descriptor (optional)

 @param columnMappings
          A ColumnMapping
 @return This builder for method chaining

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="columnMapping" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <doc>
      <![CDATA[Configure the dataset's column mapping descriptor from a File.

 The File contents must be a JSON-formatted column mapping. This format
 can produced by {@link ColumnMapping#toString()}.

 @param file
          The file
 @return This builder for method chaining
 @throws ValidationException
          If the literal is not valid JSON-encoded column mappings
 @throws DatasetIOException
          If there is an IOException accessing the file contents

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="columnMapping" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="in" type="java.io.InputStream"/>
      <doc>
      <![CDATA[Configure the dataset's column mapping descriptor from an InputStream.

 The InputStream contents must be a JSON-formatted column mapping. This
 format can produced by {@link ColumnMapping#toString()}.

 @param in
          The input stream
 @return This builder for method chaining
 @throws ValidationException
          If the literal is not valid JSON-encoded column mappings
 @throws DatasetIOException
          If there is an IOException accessing the InputStream contents

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="columnMappingLiteral" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="literal" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure the dataset's column mappings from a String literal.

 The String literal is a JSON-formatted representation that can be
 produced by {@link ColumnMapping#toString()}.

 @param literal
          A column mapping String literal
 @return This builder for method chaining
 @throws ValidationException
          If the literal is not valid JSON-encoded column mappings

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="columnMappingUri" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's column mappings from a URI.

 @param uri
          A URI to a column mapping JSON file
 @return This builder for method chaining
 @throws ValidationException
          If the literal is not valid JSON-encoded column mappings
 @throws java.io.IOException
          If accessing the URI results in an IOException

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="columnMappingUri" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Configure the dataset's column mappings from a String URI.

 @param uri
          A String URI to a column mapping JSON file
 @return This builder for method chaining
 @throws ValidationException
          If the literal is not valid JSON-encoded column mappings
 @throws java.io.IOException
          If accessing the URI results in an IOException

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="compressionType" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="compressionType" type="org.kitesdk.data.CompressionType"/>
      <doc>
      <![CDATA[Configure the dataset's compression format (optional). If not set,
 default to {@link CompressionType#Snappy}.

 @param compressionType the compression format

 @return This builder for method chaining

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="compressionType" return="org.kitesdk.data.DatasetDescriptor.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="compressionTypeName" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure the dataset's compression format (optional). If not set,
 default to {@link CompressionType#Snappy}.

 @param compressionTypeName  the name of the compression format

 @return This builder for method chaining

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="build" return="org.kitesdk.data.DatasetDescriptor"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Build an instance of the configured dataset descriptor. Subsequent calls
 produce new instances that are similarly configured.

 @since 0.9.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A fluent builder to aid in the construction of {@link DatasetDescriptor}s.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.DatasetDescriptor.Builder -->
  <!-- start class org.kitesdk.data.DatasetException -->
  <class name="DatasetException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="format" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="message" type="java.lang.String"/>
      <param name="args" type="java.lang.Object[]"/>
    </method>
    <doc>
    <![CDATA[<p>
 Exception thrown for dataset-related failures. The root of
 the dataset exception hierarchy.
 </p>
 <p>
 Implementations of the {@link Dataset} interface throw this exception if
 any of their operations fail. This is a runtime (unchecked) exception.
 </p>

 @see Dataset
 @since 0.2.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.DatasetException -->
  <!-- start class org.kitesdk.data.DatasetExistsException -->
  <class name="DatasetExistsException" extends="org.kitesdk.data.DatasetException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetExistsException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetExistsException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetExistsException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception thrown when trying to create a dataset that already exists.

 @since 0.8.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.DatasetExistsException -->
  <!-- start class org.kitesdk.data.DatasetIOException -->
  <class name="DatasetIOException" extends="org.kitesdk.data.DatasetException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetIOException" type="java.lang.String, java.io.IOException"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getIOException" return="java.io.IOException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 Exception thrown for dataset IO-related failures.
 </p>

 @since 0.9.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.DatasetIOException -->
  <!-- start class org.kitesdk.data.DatasetNotFoundException -->
  <class name="DatasetNotFoundException" extends="org.kitesdk.data.DatasetException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetNotFoundException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetNotFoundException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetNotFoundException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[<p>
 Exception thrown to indicate that a dataset was not found.
 <p>
 @since 0.9.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.DatasetNotFoundException -->
  <!-- start class org.kitesdk.data.DatasetOperationException -->
  <class name="DatasetOperationException" extends="org.kitesdk.data.DatasetException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetOperationException" type="java.lang.String, java.lang.Object[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetOperationException" type="java.lang.Throwable, java.lang.String, java.lang.Object[]"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetOperationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[{@link DatasetException} thrown when an implementation-specific step fails
 and prevents a dataset operation from completing successfully.

 @since 0.17.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.DatasetOperationException -->
  <!-- start interface org.kitesdk.data.DatasetReader -->
  <interface name="DatasetReader"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.util.Iterator&lt;E&gt;"/>
    <implements name="java.lang.Iterable&lt;E&gt;"/>
    <implements name="java.io.Closeable"/>
    <method name="hasNext" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Tests the reader to see if additional entities can be read.

 @return true if additional entities exist, false otherwise.
 @throws DatasetOperationException
            If the operation did not succeed.
 @throws DatasetIOException
            To wrap an internal {@link java.io.IOException}]]>
      </doc>
    </method>
    <method name="next" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Fetch the next entity from the reader.
 </p>
 <p>
 Calling this method when no additional data exists is illegal; you should
 use {@link #hasNext()} to test if a call to {@code read()} will succeed.
 Implementations of this method can block.
 </p>

 @return An entity of type {@code E}.
 @throws DatasetOperationException
            If the operation did not succeed.
 @throws DatasetIOException
            To wrap an internal {@link java.io.IOException}
 @throws NoSuchElementException

 @since 0.7.0]]>
      </doc>
    </method>
    <method name="remove"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Remove the last entity from the reader (OPTIONAL).
 </p>
 <p>
 This has the same semantics as {@link Iterator#remove()}, but is unlikely
 to be implemented.
 </p>

 @since 0.7.0]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Close the reader and release any system resources.
 </p>
 <p>
 No further operations of this interface (other than additional calls of
 this method) can be performed, however implementations can choose to permit
 other method calls. See implementation documentation for details.
 </p>

 @throws DatasetOperationException
            If the operation did not succeed.
 @throws DatasetIOException
            To wrap an internal {@link java.io.IOException}]]>
      </doc>
    </method>
    <method name="isOpen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 A stream-oriented dataset reader.
 </p>
 <p>
 Implementations of this interface read data from a {@link Dataset}.
 Readers are use-once objects that read from the underlying storage system to
 produce deserialized entities of type {@code E}. Normally, you are not
 expected to instantiate implementations directly.
 Instead, use the containing dataset's
 {@link Dataset#newReader()} method to get an appropriate implementation.
 Normally, you receive an instance of this interface from a dataset, invoke
 {@link #hasNext()} and {@link #next()} as necessary, and {@link #close()}
 when you are done or no more data exists.
 </p>
 <p>
 Implementations can hold system resources until the {@link #close()} method
 is called, so you <strong>must</strong> follow the normal try / finally
 pattern to ensure these resources are properly freed when the reader is
 exhausted or no longer useful. Do not rely on implementations automatically
 invoking the {@code close()} method upon object finalization (although
 implementations are free to do so, if they choose). All implementations must
 silently ignore multiple invocations of {@code close()} as well as a close of
 an unopened reader.
 </p>
 <p>
 If any method throws an exception, the reader is no longer valid, and the
 only method that can be subsequently called is {@code close()}.
 </p>
 <p>
 Implementations of {@link DatasetReader} are not required to be thread-safe;
 that is, the behavior when accessing a single instance from multiple threads
 is undefined.
 </p>

 @param <E> The type of entity produced by this reader.]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.data.DatasetReader -->
  <!-- start class org.kitesdk.data.DatasetRecordException -->
  <class name="DatasetRecordException" extends="org.kitesdk.data.DatasetException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetRecordException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="DatasetRecordException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="check"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isValid" type="boolean"/>
      <param name="message" type="java.lang.String"/>
      <param name="args" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Precondition-style validation that throws a {@link DatasetRecordException}.

 @param isValid
          {@code true} if valid, {@code false} if an exception should be
          thrown
 @param message
          A String message for the exception.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A DatasetException that signals that an individual record has failed.
 <p>
 When writing, this exception indicates that a record could not be written,
 but the writer is still valid and ready to write other records.
 <p>
 When reading, this exception indicates that a record could not be built from
 record data, but that reader is still valid and able to read other records.

 @since 0.18.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.DatasetRecordException -->
  <!-- start class org.kitesdk.data.Datasets -->
  <class name="Datasets" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Datasets"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="load" return="V extends org.kitesdk.data.View&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Load a {@link Dataset} or {@link View} for the given {@link URI}.
 <p>
 URIs must begin with {@code dataset:} or {@code view:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme.
 <p>
 If you use a dataset URI, {@code load} returns the unfiltered dataset.
 If you use a view URI, {@code load} returns a {@code View} configured to
 read a subset of the dataset.

 @param uri a {@code Dataset} or {@code View} URI
 @param type a Java class that represents an entity in the dataset
 @param <E> the type used for readers and writers created by this
          {@code Dataset}
 @param <V> the type of {@code View} expected
 @return a {@code View} for the given URI
 @throws DatasetNotFoundException if there is no dataset for the given URI
 @throws NullPointerException if any arguments are {@code null}
 @throws IllegalArgumentException
          if {@code uri} is not a dataset or view URI]]>
      </doc>
    </method>
    <method name="load" return="V extends org.kitesdk.data.View&lt;org.apache.avro.generic.GenericRecord&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Load a {@link Dataset} or {@link View} for the given {@link URI}.
 <p>
 URIs must begin with {@code dataset:} or {@code view:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme.
 <p>
 If you use a dataset URI, {@code load} returns the unfiltered dataset.
 If you use a view URI, {@code load} returns a {@code View} configured to
 read  a subset of the dataset.
 
 @param uri a {@code Dataset} or {@code View} URI
 @param <V> the type of {@code View} expected
 @return a {@code View} for the given URI
 @throws DatasetNotFoundException if there is no dataset for the given URI
 @throws NullPointerException if any arguments are {@code null}
 @throws IllegalArgumentException
          if {@code uri} is not a dataset or view URI]]>
      </doc>
    </method>
    <method name="load" return="V extends org.kitesdk.data.View&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uriString" type="java.lang.String"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Load a {@link Dataset} or {@link View} for the given {@link URI}.
 <p>
 URIs must begin with {@code dataset:} or {@code view:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme.
 <p>
 If you use a dataset URI, {@code load} returns the unfiltered dataset.
 If you use a view URI, {@code load} returns a {@code View} configured to 
 read a subset of the dataset.

 @param uriString a {@code Dataset} or {@code View} URI
 @param type a Java class that represents an entity in the dataset
 @param <E> the type used for readers and writers created by this
          {@code Dataset}
 @param <V> the type of {@code View} expected
 @return a {@code View} for the given URI
 @throws DatasetNotFoundException if there is no dataset for the given URI
 @throws NullPointerException if any arguments are {@code null}
 @throws IllegalArgumentException
          if {@code uri} is not a dataset or view URI]]>
      </doc>
    </method>
    <method name="load" return="V extends org.kitesdk.data.View&lt;org.apache.avro.generic.GenericRecord&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uriString" type="java.lang.String"/>
      <doc>
      <![CDATA[Load a {@link Dataset} or {@link View} for the given {@link URI}.
 <p>
 URIs must begin with {@code dataset:} or {@code view:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme.
 <p>
 If you use a dataset URI, {@code load} returns the unfiltered dataset.
 If you use a view URI, {@code load} returns a {@code View} configured to
 read a subset of the dataset.

 @param uriString a {@code Dataset} or {@code View} URI
 @param <V> the type of {@code View} expected
 @return a {@code View} for the given URI
 @throws DatasetNotFoundException if there is no dataset for the given URI
 @throws NullPointerException if any arguments are {@code null}
 @throws IllegalArgumentException
          if {@code uri} is not a dataset or view URI]]>
      </doc>
    </method>
    <method name="create" return="V extends org.kitesdk.data.View&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="descriptor" type="org.kitesdk.data.DatasetDescriptor"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Create a {@link Dataset} for the given dataset or view URI.
 {@code create} returns an empty dataset. You can use {@code DatasetWriter}
 to populate your dataset.
 <p>
 URIs must begin with {@code dataset:} or {@code view:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme. If the
 URI is a view URI, this method creates the underlying dataset and returns a
 view of it.

 @param uri a {@code Dataset} or {@code View} URI
 @param type a Java class that represents an entity in the dataset
 @param <E> the type used for readers and writers created by this
          {@code Dataset}
 @param <V> the type of {@code Dataset} or {@code View} expected
 @return a newly created {@code Dataset} responsible for the given URI
 @throws NullPointerException
          if {@code uri}, {@code descriptor}, or {@code type} is
          {@code null}
 @throws IllegalArgumentException
          if {@code uri} is not a dataset or view URI
 @throws DatasetExistsException
          if a {@code Dataset} for the given URI already exists
 @throws IncompatibleSchemaException
          if the schema is not compatible with existing datasets with
          shared storage (for example, in the same HBase table)]]>
      </doc>
    </method>
    <method name="create" return="V extends org.kitesdk.data.View&lt;org.apache.avro.generic.GenericRecord&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="descriptor" type="org.kitesdk.data.DatasetDescriptor"/>
      <doc>
      <![CDATA[Create a {@link Dataset} for the given dataset or view URI.
 {@code create} returns an empty dataset. You can use {@code DatasetWriter}
 to populate your dataset.
 <p>
 URIs must begin with {@code dataset:} or {@code view:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme. If the
 URI is a view URI, this method creates the underlying dataset and returns a
 view of it.

 @param uri a {@code Dataset} or {@code View} URI
 @param <V> the type of {@code Dataset} or {@code View} expected
 @return a newly created {@code Dataset} responsible for the given URI
 @throws NullPointerException
          if {@code uri} or {@code descriptor} is {@code null}
 @throws IllegalArgumentException
          if {@code uri} is not a dataset or view URI
 @throws DatasetExistsException
          if a {@code Dataset} for the given URI already exists
 @throws IncompatibleSchemaException
          if the schema is not compatible with existing datasets with
          shared storage (for example, in the same HBase table)]]>
      </doc>
    </method>
    <method name="create" return="V extends org.kitesdk.data.View&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <param name="descriptor" type="org.kitesdk.data.DatasetDescriptor"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Create a {@link Dataset} for the given dataset or view URI string.
 {@code create} returns an empty dataset. You can use {@code DatasetWriter}
 to populate your dataset.
 <p>
 URIs must begin with {@code dataset:} or {@code view:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme. If the
 URI is a view URI, this method creates the underlying dataset and returns a
 view of it.

 @param uri a {@code Dataset} or {@code View} URI string
 @param type a Java class that represents an entity in the dataset
 @param <E> the type used for readers and writers created by this
          {@code Dataset}
 @param <V> the type of {@code Dataset} or {@code View} expected
 @return a newly created {@code Dataset} responsible for the given URI
 @throws NullPointerException
          if {@code uri}, {@code descriptor}, or {@code type} is
          {@code null}
 @throws IllegalArgumentException
          if {@code uri} is not a dataset or view URI
 @throws DatasetExistsException
          if a {@code Dataset} for the given URI already exists
 @throws IncompatibleSchemaException
          if the schema is not compatible with existing datasets with
          shared storage (for example, in the same HBase table)]]>
      </doc>
    </method>
    <method name="create" return="V extends org.kitesdk.data.View&lt;org.apache.avro.generic.GenericRecord&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <param name="descriptor" type="org.kitesdk.data.DatasetDescriptor"/>
      <doc>
      <![CDATA[Create a {@link Dataset} for the given dataset or view URI string.
 {@code create} returns an empty dataset. You can use {@code DatasetWriter}
 to populate your dataset.
 <p>
 URIs must begin with {@code dataset:} or {@code view:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme. If the
 URI is a view URI, this method creates the underlying dataset and returns a
 view of it.

 @param uri a {@code Dataset} or {@code View} URI string
 @param <V> the type of {@code Dataset} or {@code View} expected
 @return a newly created {@code Dataset} responsible for the given URI
 @throws NullPointerException
          if {@code uri} or {@code descriptor} is {@code null}
 @throws IllegalArgumentException
          if {@code uri} is not a dataset or view URI
 @throws DatasetExistsException
          if a {@code Dataset} for the given URI already exists
 @throws IncompatibleSchemaException
          if the schema is not compatible with existing datasets with
          shared storage (for example, in the same HBase table)]]>
      </doc>
    </method>
    <method name="update" return="D extends org.kitesdk.data.Dataset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="descriptor" type="org.kitesdk.data.DatasetDescriptor"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Update a {@link Dataset} for the given dataset or view URI.
 <p>
 You can add columns, remove columns, or change the data type of columns 
 in your dataset, provided you don't attempt a change that is incompatible
 with written data. Avro defines rules for compatible schema evolution. See 
 <a href="http://kitesdk.org/docs/current/Schema-Evolution.html">Schema
 Evolution</a>.
 <p>
 This method updates the dataset descriptor, so you can also add
 or change properties.
 <p>
 The recommended way to update a dataset descriptor is to build it
 based on an existing descriptor. Use
 {@link DatasetDescriptor.Builder(DatasetDescriptor)} to
 build a DatasetDescriptor based on an existing instance.
 <p>
 You cannot change a dataset format or partition strategy.
 <p>
 URIs must begin with {@code dataset:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme.

 @param uri a {@code Dataset} URI
 @param type a Java class that represents an entity in the dataset
 @param <E> the type used for readers and writers created by this
          {@code Dataset}
 @param <D> the type of {@code Dataset} expected
 @return a {@code Dataset} for the given URI
 @throws NullPointerException
          if {@code uri}, {@code descriptor}, or {@code type} is
          {@code null}
 @throws IllegalArgumentException if {@code uri} is not a dataset URI
 @throws DatasetNotFoundException
          if there is no dataset for the given URI
 @throws UnsupportedOperationException
          if descriptor updates are not supported by the implementation
 @throws ConcurrentSchemaModificationException
          if the {@code Dataset} schema is updated concurrently
 @throws IncompatibleSchemaException
          if the schema is not compatible with previous schemas, or with
          existing datasets with shared storage (for example, in the same
          HBase table)]]>
      </doc>
    </method>
    <method name="update" return="D extends org.kitesdk.data.Dataset&lt;org.apache.avro.generic.GenericRecord&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="descriptor" type="org.kitesdk.data.DatasetDescriptor"/>
      <doc>
      <![CDATA[Update a {@link Dataset} for the given dataset or view URI.
 <p>
 You can add columns, remove columns, or change the data type of columns 
 in your dataset, provided you don't attempt a change that is incompatible
 with written data. Avro defines rules for compatible schema evolution. See 
 <a href="http://kitesdk.org/docs/current/Schema-Evolution.html">Schema
 Evolution</a>.
 <p>
 This method updates the dataset descriptor, so you can also add
 or change properties.
 <p>
 The recommended way to update a dataset descriptor is to build it
 based on an existing descriptor. Use
 {@link DatasetDescriptor.Builder(DatasetDescriptor)} to
 build a DatasetDescriptor based on an existing instance.
 <p>
 You cannot change a dataset format or partition strategy.
 <p>
 URIs must begin with {@code dataset:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme.

 @param uri a {@code Dataset} URI
 @param <D> the type of {@code Dataset} expected
 @return a {@code Dataset} for the given URI
 @throws NullPointerException
          if {@code uri} or {@code descriptor} is {@code null}
 @throws IllegalArgumentException if {@code uri} is not a dataset URI
 @throws DatasetNotFoundException
          if there is no dataset for the given URI
 @throws UnsupportedOperationException
          if descriptor updates are not supported by the implementation
 @throws ConcurrentSchemaModificationException
          if the {@code Dataset} schema is updated concurrently
 @throws IncompatibleSchemaException
          if the schema is not compatible with previous schemas, or with
          existing datasets with shared storage (for example, in the same
          HBase table)]]>
      </doc>
    </method>
    <method name="update" return="D extends org.kitesdk.data.Dataset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <param name="descriptor" type="org.kitesdk.data.DatasetDescriptor"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Update a {@link Dataset} for the given dataset or view URI string.
 <p>
 You can add columns, remove columns, or change the data type of columns 
 in your dataset, provided you don't attempt a change that is incompatible
 with written data. Avro defines rules for compatible schema evolution. See 
 <a href="http://kitesdk.org/docs/current/Schema-Evolution.html">Schema
 Evolution</a>.
 <p>
 This method updates the dataset descriptor, so you can also add
 or change properties.
 <p>
 The recommended way to update a dataset descriptor is to build it
 based on an existing descriptor. Use
 {@link DatasetDescriptor.Builder(DatasetDescriptor)} to
 build a DatasetDescriptor based on an existing instance.
 <p>
 You cannot change a dataset format or partition strategy.
 <p>
 URIs must begin with {@code dataset:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme.

 @param uri a {@code Dataset} URI string
 @param type a Java class that represents an entity in the dataset
 @param <E> the type used for readers and writers created by this
          {@code Dataset}
 @param <D> the type of {@code Dataset} expected
 @return a {@code Dataset} for the given URI
 @throws NullPointerException
          if {@code uri}, {@code descriptor}, or {@code type} is
          {@code null}
 @throws IllegalArgumentException if {@code uri} is not a dataset URI
 @throws DatasetNotFoundException
          if there is no dataset for the given URI
 @throws UnsupportedOperationException
          if descriptor updates are not supported by the implementation
 @throws ConcurrentSchemaModificationException
          if the {@code Dataset} schema is updated concurrently
 @throws IncompatibleSchemaException
          if the schema is not compatible with previous schemas, or with
          existing datasets with shared storage (for example, in the same
          HBase table)]]>
      </doc>
    </method>
    <method name="update" return="D extends org.kitesdk.data.Dataset&lt;org.apache.avro.generic.GenericRecord&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <param name="descriptor" type="org.kitesdk.data.DatasetDescriptor"/>
      <doc>
      <![CDATA[Update a {@link Dataset} for the given dataset or view URI string.
 <p>
 You can add columns, remove columns, or change the data type of columns 
 in your dataset, provided you don't attempt a change that is incompatible
 with written data. Avro defines rules for compatible schema evolution. See 
 <a href="http://kitesdk.org/docs/current/Schema-Evolution.html">Schema
 Evolution</a>.
 <p>
 This method updates the dataset descriptor, so you can also add
 or change properties.
 <p>
 The recommended way to update a dataset descriptor is to build it
 based on an existing descriptor. Use
 {@link DatasetDescriptor.Builder(DatasetDescriptor)} to
 build a DatasetDescriptor based on an existing instance.
 <p>
 You cannot change a dataset format or partition strategy.
 <p>
 URIs must begin with {@code dataset:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme.

 @param uri a {@code Dataset} URI string
 @param <D> the type of {@code Dataset} expected
 @return a {@code Dataset} for the given URI
 @throws NullPointerException
          if {@code uri} or {@code descriptor} is {@code null}
 @throws IllegalArgumentException if {@code uri} is not a dataset URI
 @throws DatasetNotFoundException
          if there is no dataset for the given URI
 @throws UnsupportedOperationException
          if descriptor updates are not supported by the implementation
 @throws ConcurrentSchemaModificationException
          if the {@code Dataset} schema is updated concurrently
 @throws IncompatibleSchemaException
          if the schema is not compatible with previous schemas, or with
          existing datasets with shared storage (for example, in the same
          HBase table)]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Delete a {@link Dataset} identified by the given dataset URI.
 <p>
 When you call this method using a dataset URI, both data and metadata are
 deleted. After you call this method, the dataset no longer exists, unless
 an exception is thrown.
 <p>
 When you call this method using a view URI, data in that view is deleted.
 The dataset's metadata is not changed. This can throw an
 {@code UnsupportedOperationException} if the delete requires additional
 work. For example, if some, but not all, of the data in an underlying data
 file must be removed, then the implementation is allowed to reject the
 deletion rather than copy the remaining records to a new file.
 An implementation must document under what conditions it accepts deletes,
 and under what conditions it rejects them.
 <p>
 URIs must begin with {@code dataset:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme.

 @param uri a {@code Dataset} URI
 @return {@code true} if any data or metadata is removed, {@code false}
          otherwise
 @throws NullPointerException if {@code uri} is null
 @throws IllegalArgumentException if {@code uri} is not a dataset URI]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Delete a {@link Dataset} identified by the given dataset URI string.  
 <p>
 When you call this method using a dataset URI, both data and metadata are
 deleted. After you call this method, the dataset no longer exists, unless
 an exception is thrown.
 <p>
 When you call this method using a view URI, data in that view is deleted.
 The dataset's metadata is not changed. This can throw an
 {@code UnsupportedOperationException} if the delete requires additional
 work. For example, if some, but not all, of the data in an underlying data
 file must be removed, then the implementation is allowed to reject the
 deletion rather than copy the remaining records to a new file.
 An implementation must document under what conditions it accepts deletes,
 and under what conditions it rejects them.
 <p>
 URIs must begin with {@code dataset:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme.

 @param uri a {@code Dataset} URI string
 @return {@code true} if any data or metadata is removed, {@code false}
          otherwise
 @throws NullPointerException if {@code uri} is null
 @throws IllegalArgumentException if {@code uri} is not a dataset URI]]>
      </doc>
    </method>
    <method name="exists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Check whether a {@link Dataset} identified by the given URI exists.
 <p>
 URIs must begin with {@code dataset:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme.

 @param uri a {@code Dataset} URI
 @return {@code true} if the dataset exists, {@code false} otherwise
 @throws NullPointerException if {@code uri} is null
 @throws IllegalArgumentException if {@code uri} is not a dataset URI]]>
      </doc>
    </method>
    <method name="exists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Check whether a {@link Dataset} identified by the given URI string exists.
 <p>
 URIs must begin with {@code dataset:}. The remainder of
 the URI is implementation specific, depending on the dataset scheme.

 @param uri a {@code Dataset} URI string
 @return {@code true} if the dataset exists, {@code false} otherwise
 @throws NullPointerException if {@code uri} is null
 @throws IllegalArgumentException if {@code uri} is not a dataset URI]]>
      </doc>
    </method>
    <method name="list" return="java.util.Collection&lt;java.net.URI&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[List the {@link Dataset} URIs in the repository identified by the URI.
 <p>
 URI formats are defined by {@code Dataset} implementations. The repository
 URIs you pass to this method must begin with {@code repo:}. For example, to 
 list the {@code Dataset} URIs for the Hive repository, provide the URI
 {@code repo:hive}.

 @param uri a {@code DatasetRepository} URI
 @return the URIs present in the {@code DatasetRepository}
 @throws NullPointerException if {@code uri} is null
 @throws IllegalArgumentException if {@code uri} is not a repository URI]]>
      </doc>
    </method>
    <method name="list" return="java.util.Collection&lt;java.net.URI&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[List the {@link Dataset} URIs in the repository identified by the URI
 string.
 <p>
 URI formats are defined by {@code Dataset} implementations. The repository
 URIs you pass to this method must begin with {@code repo:}. For example, to 
 list the {@code Dataset} URIs for the Hive repository, provide the URI
 {@code repo:hive}.
 
 @param uri a {@code DatasetRepository} URI string
 @return the URIs present in the {@code DatasetRepository}
 @throws NullPointerException if {@code URI} is null
 @throws IllegalArgumentException if {@code uri} is not a repository URI]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Methods for working with {@link Dataset} instances.
 <p>
 <b>URIs</b>
 <p>
 All methods require a URI that identifies a dataset, view, or
 repository. The URI must begin with the scheme {@code dataset:}, 
 {@code view:}, or {@code repo:}. The remainder of the URI is 
 implementation specific, depending on the dataset scheme.
 <p>
 For example, the URI {@code dataset:hive:movies/ratings}
 references a dataset named <i>ratings</i> in the
 <i>movies</i> namespace, stored in Hive.
 <p>
 The URI {@code view:hive:movies/ratings?year=2015&month=3}
 references a view of the same <i>ratings</i> dataset. The view
 is filtered to include records from only March, 2015.
 <p>
 See <a href="http://kitesdk.org/docs/current/URIs.html">Dataset and View
 URIs</a> for the available URI patterns.
 <p>
 <b>Dataset Descriptors</b>
 <p>
 Some methods require a {@link DatasetDescriptor} that encapsulates metadata
 about a dataset. Descriptors are built using a
 {@link DatasetDescriptor.Builder descriptor builder}.
 <p>
 <b>Entities</b>
 <p>
 <i>Entities</i> are analagous to <i>records</i> in database terminology.
 The term is used in the API to emphasize that an entity can include not
 only primitive objects, but also complex objects such as hash maps.
 <p>
 Some methods accept an entity class that will be used by Kite when returning
 entities from a dataset or view.

 @since 0.8.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.Datasets -->
  <!-- start interface org.kitesdk.data.DatasetWriter -->
  <interface name="DatasetWriter"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Closeable"/>
    <method name="write"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="E"/>
      <doc>
      <![CDATA[<p>
 Write an entity to the underlying dataset.
 </p>
 <p>
 If any exception other than {@link DatasetRecordException} is thrown, this
 writer is no longer valid and should be closed.
 </p>

 @param entity The entity to write
 @throws DatasetRecordException
            If a record could not be written, but the writer is still valid.
 @throws DatasetIOException
            To wrap an internal {@link java.io.IOException}]]>
      </doc>
    </method>
    <method name="close"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Close the writer and release any system resources. If this method returns without
 throwing an exception then any entity that was successfully written with
 {@link #write(Object)} will be stored to stable storage.
 </p>
 <p>
 No further operations of this interface (other than additional calls to
 this method) can be performed; however, implementations can choose to
 permit other method calls. See implementation documentation for details.
 </p>
 @throws DatasetOperationException
            If the operation did not succeed.
 @throws DatasetIOException
            To wrap an internal {@link java.io.IOException}]]>
      </doc>
    </method>
    <method name="isOpen" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 A stream-oriented dataset writer.
 </p>
 <p>
 Implementations of this interface write data to a {@link Dataset}.
 Writers are use-once objects that serialize entities of type {@code E} and
 write them to the underlying storage system. Normally, you are
 not expected to instantiate implementations directly. Instead, use the
 containing dataset's {@link Dataset#newWriter()} method to get an appropriate
 implementation. You should receive an instance of this interface from a
 dataset, invoke {@link #write(Object)} and {@link #close()} when they are done,
 or no more data exists.
 </p>
 <p>
 Implementations can hold system resources until the {@link #close()} method
 is called, so you <strong>must</strong> follow the normal try / finally
 pattern to ensure these resources are properly freed when the writer is no
 longer needed. Do not rely on implementations automatically invoking the
 {@code close} method upon object finalization (implementations must not do
 so). All implementations must silently ignore multiple invocations of
 {@code close} as well as a close of an unopened writer.
 </p>
 <p>
 If any method throws an exception other than {@link DatasetRecordException},
 the writer is no longer valid, and the only method that can be subsequently
 called is {@code close}.
 </p>
 <p>
 Implementations of {@link DatasetWriter} are typically not thread-safe; that
 is, the behavior when accessing a single instance from multiple threads is
 undefined.
 </p>

 @param <E> The type of entity accepted by this writer.]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.data.DatasetWriter -->
  <!-- start class org.kitesdk.data.FieldMapping -->
  <class name="FieldMapping" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="key" return="org.kitesdk.data.FieldMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="column" return="org.kitesdk.data.FieldMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="family" type="java.lang.String"/>
      <param name="qualifier" type="java.lang.String"/>
    </method>
    <method name="keyAsColumn" return="org.kitesdk.data.FieldMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="family" type="java.lang.String"/>
    </method>
    <method name="keyAsColumn" return="org.kitesdk.data.FieldMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="family" type="java.lang.String"/>
      <param name="qualifierPrefix" type="java.lang.String"/>
    </method>
    <method name="counter" return="org.kitesdk.data.FieldMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="family" type="java.lang.String"/>
      <param name="qualifier" type="java.lang.String"/>
    </method>
    <method name="occ" return="org.kitesdk.data.FieldMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="version" return="org.kitesdk.data.FieldMapping"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="getFieldName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMappingType" return="org.kitesdk.data.FieldMapping.MappingType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getPrefix" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFamily" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getFamilyAsString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQualifier" return="byte[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getQualifierAsString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Represents how to store a Schema field.

 @since 0.14.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.FieldMapping -->
  <!-- start class org.kitesdk.data.FieldMapping.MappingType -->
  <class name="FieldMapping.MappingType" extends="java.lang.Enum&lt;org.kitesdk.data.FieldMapping.MappingType&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.kitesdk.data.FieldMapping.MappingType[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.kitesdk.data.FieldMapping.MappingType"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[The supported Mapping Types, which control how an entity field maps to
 columns in an HBase table.

 @since 0.14.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.FieldMapping.MappingType -->
  <!-- start interface org.kitesdk.data.Flushable -->
  <interface name="Flushable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="java.io.Flushable"/>
    <method name="flush"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ensure that data has been flushed to OS buffers on all replica data nodes.
 <p>
 This method has a stronger guarantee than {@link java.io.Flushable#flush}.
 When this method returns, data already written has been flushed to the OS
 buffers on all data nodes responsible for replicas.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A writer that can guarantee data is present on data nodes.
 <p>
 {@link #flush} has a stronger guarantee than {@link java.io.Flushable#flush}.
 When it returns, data already written is flushed to the OS buffers on all
 data nodes responsible for replicas.
 <p>
 Once data has been flushed, it will be tolerant to single-node and rack
 failures.

 @since 0.18.0]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.data.Flushable -->
  <!-- start class org.kitesdk.data.Format -->
  <class name="Format" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the format's name.
 @return the name]]>
      </doc>
    </method>
    <method name="getExtension" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the extension for use in filenames. The extension does not include a
 dot.
 @return the extension]]>
      </doc>
    </method>
    <method name="getSupportedCompressionTypes" return="java.util.Set&lt;org.kitesdk.data.CompressionType&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the {@link CompressionType}s supported by this {@code Format}.

 @return the supported compression types

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="getDefaultCompressionType" return="org.kitesdk.data.CompressionType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the default {@link CompressionType} supported by this {@code Format}.

 @return the default compression type

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 The data format used for encoding the data in a {@link Dataset}.
 </p>
 <p>
 There are a small number of formats provided. The default is
 {@link Formats#AVRO}, which is used when you do not explicitly configure a
 format.
 </p>

 @since 0.2.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.Format -->
  <!-- start class org.kitesdk.data.Formats -->
  <class name="Formats" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="fromString" return="org.kitesdk.data.Format"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="formatName" type="java.lang.String"/>
      <doc>
      <![CDATA[Return a {@link Format} for the format name specified. If {@code formatName}
 is not a valid name, an IllegalArgumentException is thrown. Currently the
 formats <q>avro</q>, <q>csv</q>, and <q>parquet</q> are supported. Format names are
 case sensitive.

 @since 0.9.0
 @return an appropriate instance of Format
 @throws IllegalArgumentException if {@code formatName} is not a valid format.]]>
      </doc>
    </method>
    <field name="AVRO" type="org.kitesdk.data.Format"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[AVRO: the
 <a href="http://avro.apache.org/docs/current/spec.html#Object+Container+Files">
 Avro row-oriented format</a>]]>
      </doc>
    </field>
    <field name="PARQUET" type="org.kitesdk.data.Format"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[PARQUET: the <a href="http://parquet.io/">Parquet columnar format</a>]]>
      </doc>
    </field>
    <field name="JSON" type="org.kitesdk.data.Format"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[JSON: white-space separated json values (read-only).

 @since 0.18.0]]>
      </doc>
    </field>
    <field name="CSV" type="org.kitesdk.data.Format"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[CSV: comma-separated values (read-only).

 @since 0.9.0]]>
      </doc>
    </field>
    <field name="INPUTFORMAT" type="org.kitesdk.data.Format"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[INPUTFORMAT: a mapreduce InputFormat (read-only).

 @since 0.18.0]]>
      </doc>
    </field>
    <doc>
    <![CDATA[<p>
 Contains constant definitions for the standard {@link Format} instances
 supported by the library. {@link #AVRO} is the default format.
 </p>

 @since 0.2.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.Formats -->
  <!-- start class org.kitesdk.data.IncompatibleSchemaException -->
  <class name="IncompatibleSchemaException" extends="org.kitesdk.data.ValidationException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="IncompatibleSchemaException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IncompatibleSchemaException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="IncompatibleSchemaException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="check"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isValid" type="boolean"/>
      <param name="message" type="java.lang.String"/>
      <param name="args" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Precondition-style validation that throws a {@link ValidationException}.

 @param isValid
          {@code true} if valid, {@code false} if an exception should be
          thrown
 @param message
          A String message for the exception.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 Exception thrown when a schema update is not compatible
 with the previous schema (or schemas) or with existing
 datasets (if shared storage is used, for example).
 <p>
 @since 0.9.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.IncompatibleSchemaException -->
  <!-- start class org.kitesdk.data.Key -->
  <class name="Key" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="get" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="index" type="int"/>
      <doc>
      <![CDATA[Returns the value for {@code index}.

 @param index the {@code index} of the value to return
 @return the Object stored at {@code index}]]>
      </doc>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="obj" type="java.lang.Object"/>
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[<p>
 A key for retrieving entities from a {@link RandomAccessDataset}.
 </p>

 @since 0.9.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.Key -->
  <!-- start class org.kitesdk.data.Key.Builder -->
  <class name="Key.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Key.Builder" type="org.kitesdk.data.RandomAccessDataset"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Construct a {@link Builder} for a {@link RandomAccessDataset}.]]>
      </doc>
    </constructor>
    <method name="add" return="org.kitesdk.data.Key.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Add a key value for the named field.

 @throws IllegalArgumentException If the there is no key field named
 <code>name</code> for this builder's dataset.
 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="build" return="org.kitesdk.data.Key"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Build an instance of the configured key.

 @throws IllegalStateException If any required key field is missing.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A fluent builder to aid in the construction of {@link Key} objects.

 @since 0.9.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.Key.Builder -->
  <!-- start class org.kitesdk.data.PartitionStrategy -->
  <class name="PartitionStrategy" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getCardinality" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[<p>
 Return the cardinality produced by the contained field partitioners.
 </p>
 <p>
 This can be used to aid in calculating resource usage during certain
 operations. For example, when writing data to a partitioned dataset, you
 can use this method to estimate (or discover exactly, depending on the
 partition functions) how many leaf partitions exist.
 </p>
 <p>
 <strong>Warning:</strong> This method is allowed to lie and should be
 treated only as a hint. Some partition functions are fixed (for example, 
 hash modulo number of buckets), while others are open-ended (for
 example, discrete value) and depend on the input data.
 </p>
 
 @return The estimated (or possibly concrete) number of leaf partitions.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="o" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="pretty" type="boolean"/>
      <doc>
      <![CDATA[@param pretty {@code true} to indent and format JSON
 @return this PartitionStrategy as its JSON representation]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 The strategy used to determine how a dataset is partitioned.
 </p>
 <p>
 When a {@link Dataset} is configured
 with a partition strategy, that data is considered partitioned. Any entities
 written to a partitioned dataset are evaluated with its
 {@code PartitionStrategy} to determine which partition to write to.
 </p>
 <p>
 You should use the inner {@link Builder} to create new instances.
 </p>
 
 @see DatasetDescriptor
 @see Dataset]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.PartitionStrategy -->
  <!-- start class org.kitesdk.data.PartitionStrategy.Builder -->
  <class name="PartitionStrategy.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="PartitionStrategy.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hash" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="buckets" type="int"/>
      <doc>
      <![CDATA[Configure a hash partitioner with the specified number of
 {@code buckets}.

 The partition name is the source field name with a "_hash" suffix.
 For example, hash("color", 34) creates "color_hash" partitions.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param buckets
          The number of buckets into which data is to be partitioned.
 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="hash" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <param name="buckets" type="int"/>
      <doc>
      <![CDATA[Configure a hash partitioner with the specified number of
 {@code buckets}. If name is null, the partition name will be the source
 field name with a "_hash" suffix. For example, hash("color", null, 34)
 will create "color_hash" partitions.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @param buckets
          The number of buckets into which data is to be partitioned.
 @return An instance of the builder for method chaining.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="identity" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure an identity partitioner.

 The partition name is the source field name with a "_copy" suffix.
 For example, identity("color", String.class, 34) creates "color_copy"
 partitions.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @return An instance of the builder for method chaining.
 @see IdentityFieldPartitioner
 @since 0.14.0]]>
      </doc>
    </method>
    <method name="identity" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure an identity partitioner. If name is null, the partition name
 will be the source field name with a "_copy" suffix. For example,
 identity("color", null, ...) will create "color_copy" partitions.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          A name for the partition field
 @return An instance of the builder for method chaining.
 @see IdentityFieldPartitioner
 @since 0.14.0]]>
      </doc>
    </method>
    <method name="identity" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="cardinalityHint" type="int"/>
      <doc>
      <![CDATA[Configure an identity partitioner with a cardinality hint of
 {@code cardinalityHint}.

 The partition name is the source field name with a "_copy" suffix.
 For example, identity("color", String.class, 34) creates "color_copy"
 partitions.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param cardinalityHint
          A hint as to the number of partitions that will be created (i.e.
          the number of discrete values for the field {@code name} in the
          data).
 @return An instance of the builder for method chaining.
 @see IdentityFieldPartitioner
 @since 0.14.0]]>
      </doc>
    </method>
    <method name="identity" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <param name="cardinalityHint" type="int"/>
      <doc>
      <![CDATA[Configure an identity partitioner with a cardinality hint of
 {@code cardinalityHint}. If name is null, the partition name will be the source
 field name with a "_copy" suffix. For example, identity("color", null, ...)
 will create "color_copy" partitions.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          A name for the partition field
 @param cardinalityHint
          A hint as to the number of partitions that will be created (i.e.
          the number of discrete values for the field {@code name} in the
          data).
 @return An instance of the builder for method chaining.
 @see IdentityFieldPartitioner
 @since 0.14.0]]>
      </doc>
    </method>
    <method name="range" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="upperBounds" type="int[]"/>
      <doc>
      <![CDATA[Configure a range partitioner with a set of {@code upperBounds}.

 The partition name will be the source field name with a "_bound" suffix.
 For example, range("number", 5, 10) creates "number_bound"
 partitions.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param upperBounds
          A variadic list of upper bounds of each partition.
 @return An instance of the builder for method chaining.
 @see IntRangeFieldPartitioner]]>
      </doc>
    </method>
    <method name="range" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="upperBounds" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Configure a range partitioner for strings with a set of {@code upperBounds}.

 The partition name will be the source field name with a "_bound" suffix.
 For example, range("color", "blue", "green") creates "color_bound"
 partitions.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param upperBounds
          A variadic list of upper bounds of each partition.
 @return An instance of the builder for method chaining.]]>
      </doc>
    </method>
    <method name="fixedSizeRange" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="size" type="long"/>
      <doc>
      <![CDATA[Configure a range partitioner with fixed-size ranges. A value <code>v</code>
 is placed in the partition <code>floor(v/size)*size</code>.

 The partition name will be the source field name with a "_range" suffix.
 For example, fixedSizeRange("number", 10) creates "number_range"
 partitions.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param size
          The size of the range.
 @return An instance of the builder for method chaining.
 @see IntRangeFieldPartitioner
 @since 1.1.0]]>
      </doc>
    </method>
    <method name="fixedSizeRange" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <param name="size" type="long"/>
      <doc>
      <![CDATA[Configure a range partitioner with fixed-size ranges. A value <code>v</code>
 is placed in the partition <code>floor(v/size)*size</code>.

 If name is null, the partition name will be the source field name with a "_range" suffix.
 For example, fixedSizeRange("number", 10) creates "number_range"
 partitions.

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @param size
          The size of the range.
 @return An instance of the builder for method chaining.
 @see IntRangeFieldPartitioner
 @since 1.1.0]]>
      </doc>
    </method>
    <method name="year" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the year from a timestamp field.
 The UTC timezone is assumed. If name is null, the partition entity name
 will be "year".

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @return An instance of the builder for method chaining.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="year" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the year from a timestamp field.
 The UTC timezone is assumed. The partition entity name is "year".

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @return An instance of the builder for method chaining.
 @since 0.8.0]]>
      </doc>
    </method>
    <method name="month" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the month from a timestamp field.
 The UTC timezone is assumed. If name is null, the partition entity name
 will be "month".

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @return An instance of the builder for method chaining.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="month" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the month from a timestamp field.
 The UTC timezone is assumed. The partition entity name is "month".

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @return An instance of the builder for method chaining.
 @since 0.8.0]]>
      </doc>
    </method>
    <method name="day" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the day from a timestamp field.
 The UTC timezone is assumed. If name is null, the partition entity name
 will be "day".

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @return An instance of the builder for method chaining.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="day" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the day from a timestamp field.
 The UTC timezone is assumed. The partition entity name is "day".

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @return An instance of the builder for method chaining.
 @since 0.8.0]]>
      </doc>
    </method>
    <method name="hour" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the hour from a timestamp field.
 The UTC timezone is assumed. If name is null, the partition entity name
 will be "hour".

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @return An instance of the builder for method chaining.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="hour" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the hour from a timestamp field.
 The UTC timezone is assumed. The partition entity name is "hour".

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @return An instance of the builder for method chaining.
 @since 0.8.0]]>
      </doc>
    </method>
    <method name="minute" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the minute from a timestamp field.
 The UTC timezone is assumed. If name is null, the partition entity name
 will be "minute".

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @param name
          The entity field name of the partition.
 @return An instance of the builder for method chaining.
 @since 0.3.0]]>
      </doc>
    </method>
    <method name="minute" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner for extracting the minute from a timestamp field.
 The UTC timezone is assumed. The partition entity name is "minute".

 @param sourceName
          The entity field name from which to get values to be
          partitioned.
 @return An instance of the builder for method chaining.
 @since 0.8.0]]>
      </doc>
    </method>
    <method name="dateFormat" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="sourceName" type="java.lang.String"/>
      <param name="name" type="java.lang.String"/>
      <param name="format" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner that applies a custom date format to a timestamp
 field. The UTC timezone is assumed.

 @param sourceName
          The entity field name of the timestamp to format
 @param name
          A name for the partitions created by the format (e.g. "day")
 @param format
          A {@link java.text.SimpleDateFormat} format-string.
 @return This builder for method chaining.
 @since 0.9.0]]>
      </doc>
    </method>
    <method name="provided" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner that uses values always provided at runtime.
 <p>
 The partitioner created by this method will expect {@link String} values.

 @param name
          A name for the partitions
 @return This builder for method chaining

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="provided" return="org.kitesdk.data.PartitionStrategy.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="valuesType" type="java.lang.String"/>
      <doc>
      <![CDATA[Configure a partitioner that uses values always provided at runtime.
 <p>
 The partitioner created by this method will expect values based on the
 given {@code valuesType}: "string", "int", or "long".

 @param name
          A name for the partitions
 @param valuesType
          A type string for values this partitioner will expect; one of
          "string", "int", or "long". If null, the default is "string".
 @return This builder for method chaining

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="build" return="org.kitesdk.data.PartitionStrategy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Build a configured {@link PartitionStrategy} instance.

 This builder should be considered single use and discarded after a call
 to this method.

 @return The configured instance of {@link PartitionStrategy}.
 @since 0.9.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A fluent builder to aid in the construction of {@link PartitionStrategy}s.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.PartitionStrategy.Builder -->
  <!-- start interface org.kitesdk.data.PartitionView -->
  <interface name="PartitionView"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.data.View&lt;E&gt;"/>
    <method name="getLocation" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the location of this partition as a {@link URI}.

 @return a {@code URI} for the location of this partition.
 @since 1.1.0]]>
      </doc>
    </method>
    <method name="deleteAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Deletes the entities included in this {@link View}.
 <p>
 Unlike {@link View#deleteAll()}, implementations are not allowed to throw
 {@link UnsupportedOperationException} and must support this method in all
 {@code PartitionView} implementations.

 @return true if any data was deleted, false if the View was already empty
 @throws DatasetIOException
          if the requested delete failed because of an IOException
 @since 1.1.0]]>
      </doc>
    </method>
    <method name="newWriter" return="org.kitesdk.data.DatasetWriter&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an appropriate {@link DatasetWriter} implementation based on the
 constraints for this  {@code View} of the underlying {@code Dataset}.
 <p>
 Although the {@code view} is limited to a particular location in the
 dataset when reading, writers returned by this method will not necessarily
 write to that location. Instead, writers are subject to the logical
 constraints of this {@code PartitionView}.
 <p>
 Implementations are free to return different types of writers depending on
 the disposition of the data. For example, a partitioned dataset may use a
 different writer than that of a non-partitioned dataset. Clients should not
 make any assumptions about the returned implementations: implementations
 are free to change their internal structure at any time.

 @throws DatasetException]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code PartitionView} is a subset of a {@link Dataset} that corresponds to
 a single partition, with a location.

 @param <E>
      The type of entities stored in the {@code Dataset} underlying this
      {@code View}.
 @since 1.1.0]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.data.PartitionView -->
  <!-- start interface org.kitesdk.data.RandomAccessDataset -->
  <interface name="RandomAccessDataset"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.data.Dataset&lt;E&gt;"/>
    <method name="get" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.kitesdk.data.Key"/>
      <doc>
      <![CDATA[Return the entity stored in the dataset at the row specified with {@link
 Key} <code>key</code>. Return null if no such entity exists.

 @param key
          The key of the entity to get
 @return The entity of type E, or null if one is not found]]>
      </doc>
    </method>
    <method name="put" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="E"/>
      <doc>
      <![CDATA[Put the entity into the dataset.

 @param entity
          The entity to store
 @return True if the put succeeded, false if the put failed due to an update
         conflict]]>
      </doc>
    </method>
    <method name="increment" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.kitesdk.data.Key"/>
      <param name="fieldName" type="java.lang.String"/>
      <param name="amount" type="long"/>
      <doc>
      <![CDATA[Increment a field named <code>fieldName</code> on the entity by the
 specified amount.

 @param key
          The key of the entity to increment
 @param fieldName
          The name of the field on the entity to increment. If the fieldName
          doesn't exist, an exception is thrown.
 @param amount
          The amount to increment the field by
 @return The new field amount.]]>
      </doc>
    </method>
    <method name="delete"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="org.kitesdk.data.Key"/>
      <doc>
      <![CDATA[Deletes the entity in the dataset with {@link Key} <code>key</code>.

 @param key
          The key of the entity to delete.]]>
      </doc>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="E"/>
      <doc>
      <![CDATA[Deletes the entity passed to this method in the dataset.
 If that entity has a checkConflict field, then the delete is performed only 
 if the entity in the dataset has the same value as the one in the
 passed <code>entity</code> object.
.
 @param entity
          The entity, whose checkConflict field can be validated before the
          delete is performed
 @return True if the delete succeeded, false if the delete failed due to an 
         update conflict]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 A {@link Dataset} that supports random access operations on entities.
 </p>
 <p>
 Implementations of {@link RandomAccessDataset} are immutable.
 </p>

 @param <E> The type of entities stored in this {@code RandomAccessDataset}.

 @see Dataset
 @since 0.9.0]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.data.RandomAccessDataset -->
  <!-- start interface org.kitesdk.data.RefinableView -->
  <interface name="RefinableView"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.data.View&lt;E&gt;"/>
    <method name="with" return="org.kitesdk.data.RefinableView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="values" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Creates a sub-{@code View}, restricted to entities whose <code>name</code>
 field is equal to any of the given <code>values</code>. If you specify no 
 <code>values</code>, the view is restricted to entities whose 
 <code>name</code> field is non-null.

 @param name the field name of the entity
 @return the restricted view]]>
      </doc>
    </method>
    <method name="from" return="org.kitesdk.data.RefinableView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Comparable"/>
      <doc>
      <![CDATA[Creates a sub-{@code View}, restricted to entities whose <code>name</code> 
 field is greater than or equal to the given <code>value</code>.

 @param name the field name of the entity
 @return the restricted view]]>
      </doc>
    </method>
    <method name="fromAfter" return="org.kitesdk.data.RefinableView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Comparable"/>
      <doc>
      <![CDATA[Creates a sub-{@code View}, restricted to entities whose <code>name</code> 
 field is greater than the given <code>value</code>.

 @param name the field name of the entity
 @return the restricted view]]>
      </doc>
    </method>
    <method name="to" return="org.kitesdk.data.RefinableView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Comparable"/>
      <doc>
      <![CDATA[Creates a sub-{@code View}, restricted to entities whose <code>name</code> 
 field is less than or equal to the given <code>value</code>.

 @param name the field name of the entity
 @return the restricted view]]>
      </doc>
    </method>
    <method name="toBefore" return="org.kitesdk.data.RefinableView&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Comparable"/>
      <doc>
      <![CDATA[Creates a sub-{@code View}, restricted to entities whose <code>name</code> 
 field is less than the given <code>value</code>.

 @param name the field name of the entity
 @return the restricted view]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code RefinableView} specifies a subset of a {@link Dataset} by one or 
 more logical constraints.

 @param <E>
      The type of entities stored in the {@code Dataset} underlying this
      {@code RefinableView}.
 @since 0.11.0]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.data.RefinableView -->
  <!-- start class org.kitesdk.data.SchemaNotFoundException -->
  <class name="SchemaNotFoundException" extends="org.kitesdk.data.DatasetException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SchemaNotFoundException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SchemaNotFoundException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SchemaNotFoundException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[<p>
 Exception thrown to indicate that there is a problem
 finding a particular version of a schema.
 <p>
 @since 0.9.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.SchemaNotFoundException -->
  <!-- start class org.kitesdk.data.SerializationException -->
  <class name="SerializationException" extends="org.kitesdk.data.DatasetException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SerializationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception thrown when an object cannot be serialized to,
 or deserialized from, its binary representation.
 @since 0.9.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.SerializationException -->
  <!-- start interface org.kitesdk.data.Signalable -->
  <interface name="Signalable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.data.View&lt;E&gt;"/>
    <method name="signalReady"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Signal that the view's data is ready for consumption.

 Note that an {@link #isEmpty() empty} view may be signaled as ready.

 @since 1.1.0]]>
      </doc>
    </method>
    <method name="isReady" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns {@code true} if the view's data is ready for consumption.

 A view is considered ready if
 <ul>
 <li>it has been {@link #signalReady() signaled ready}</li>
 <li>it is a subset of a ready view (may not be implemented)</li>
 <li>
   it is completely covered by a union of ready views, or is a subset of such
   a union (may not be implemented)
 </li>
 <ul>

 Note that ready views may also be {@link #isEmpty() empty}.

 @since 1.1.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Signalable views may signal consumers when their underlying data is ready for
 consumption. Not all View implementations provide this capability.

 @since 1.1.0]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.data.Signalable -->
  <!-- start interface org.kitesdk.data.Syncable -->
  <interface name="Syncable"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="sync"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Ensure that data has been synced to disk on all replica data nodes.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A writer that can guarantee data is persisted to disk.
 <p>
 When {@link #sync} returns, data already written is flushed to data nodes
 responsible for replicas and persisted to disk, not just to the underlying
 OS buffer.

 @since 0.18.0]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.data.Syncable -->
  <!-- start class org.kitesdk.data.TypeNotFoundException -->
  <class name="TypeNotFoundException" extends="org.kitesdk.data.DatasetException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TypeNotFoundException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TypeNotFoundException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="TypeNotFoundException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[<p>
 Exception thrown to indicate that there is a problem
 finding a given type.
 <p>
 @since 0.15.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.TypeNotFoundException -->
  <!-- start class org.kitesdk.data.UnknownFormatException -->
  <class name="UnknownFormatException" extends="org.kitesdk.data.DatasetException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="UnknownFormatException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnknownFormatException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="UnknownFormatException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Exception thrown when a Dataset is in an unknown format.
 @since 0.7.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.UnknownFormatException -->
  <!-- start class org.kitesdk.data.URIBuilder -->
  <class name="URIBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="URIBuilder" type="java.lang.String, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a builder based on the given repository URI and
 {@link Dataset#getName() dataset name}.

 @param repoUri the repository URI
 @param namespace A namespace, or logical group name, for the dataset.
 @param datasetName the {@link Dataset} name

 @since 0.17.0]]>
      </doc>
    </constructor>
    <constructor name="URIBuilder" type="java.net.URI, java.lang.String, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a builder based on the given repository URI and
 {@link Dataset#getName() dataset name}.

 @param repoUri the repository URI
 @param namespace A namespace, or logical group name, for the dataset.
 @param dataset the {@link Dataset} name

 @since 0.17.0]]>
      </doc>
    </constructor>
    <constructor name="URIBuilder" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a builder based on the given dataset or view URI string.

 @param uri a dataset or view URI String]]>
      </doc>
    </constructor>
    <constructor name="URIBuilder" type="java.net.URI"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Constructs a builder based on the given dataset or view URI.

 @param uri a dataset or view URI

 @since 0.17.0]]>
      </doc>
    </constructor>
    <method name="build" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="repoUri" type="java.lang.String"/>
      <param name="namespace" type="java.lang.String"/>
      <param name="dataset" type="java.lang.String"/>
      <doc>
      <![CDATA[Builds a dataset URI from the given repository URI string, namespace, and
 dataset name.

 @param repoUri a repository URI string
 @param namespace a String namespace
 @param dataset a String dataset name
 @return a dataset URI for the namespace and dataset name in the repository

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="build" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="repoUri" type="java.net.URI"/>
      <param name="namespace" type="java.lang.String"/>
      <param name="dataset" type="java.lang.String"/>
      <doc>
      <![CDATA[Builds a dataset URI from the given repository URI, namespace, and dataset
 name.

 @param repoUri a repository URI
 @param namespace a String namespace
 @param dataset a String dataset name
 @return a dataset URI for the namespace and dataset name in the repository

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="with" return="org.kitesdk.data.URIBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds a view constraint equivalent to
 {@link org.kitesdk.data.RefinableView#with(String, Object...)}

 @param name the field name of the Entity
 @param value the field value
 @return this builder for method chaining

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="namespace" return="org.kitesdk.data.URIBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namespace" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the namespace that is used to construct the dataset URI.

 @param namespace a String namespace
 @return this builder for method chaining

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="dataset" return="org.kitesdk.data.URIBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="dataset" type="java.lang.String"/>
      <doc>
      <![CDATA[Sets the dataset name that is used to construct the dataset URI.

 @param dataset a String dataset name
 @return this builder for method chaining

 @since 0.17.0]]>
      </doc>
    </method>
    <method name="build" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a dataset or view URI encompassing the given constraints. The
 referenced {@link Dataset} or {@link View} may be loaded again with
 {@link Datasets#load(URI, Class)}.

 @return a dataset or view URI

 @since 0.17.0]]>
      </doc>
    </method>
    <field name="DATASET_NAME_OPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NAMESPACE_OPTION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NAMESPACE_DEFAULT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DATASET_SCHEME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="VIEW_SCHEME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="REPO_SCHEME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Builds dataset and view URIs

 @since 0.17.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.URIBuilder -->
  <!-- start class org.kitesdk.data.ValidationException -->
  <class name="ValidationException" extends="org.kitesdk.data.DatasetException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ValidationException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ValidationException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="ValidationException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="check"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="isValid" type="boolean"/>
      <param name="message" type="java.lang.String"/>
      <param name="args" type="java.lang.Object[]"/>
      <doc>
      <![CDATA[Precondition-style validation that throws a {@link ValidationException}.

 @param isValid
          {@code true} if valid, {@code false} if an exception should be
          thrown
 @param message
          A String message for the exception.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 Exception thrown to indicate that there was a problem
 parsing or validating a schema, partition strategy, or column mapping.
 <p>

 @since 0.14.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.ValidationException -->
  <!-- start interface org.kitesdk.data.View -->
  <interface name="View"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getDataset" return="org.kitesdk.data.Dataset&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the underlying {@link org.kitesdk.data.Dataset} for the
 {@code View}.

 @return the underlying {@code Dataset}]]>
      </doc>
    </method>
    <method name="newReader" return="org.kitesdk.data.DatasetReader&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an appropriate {@link DatasetReader} implementation based on this
 {@code View} of the underlying {@code Dataset} implementation.

 Implementations are free to return different types of readers, depending on
 the disposition of the data. For example, a partitioned dataset can use a
 different reader than that of a non-partitioned dataset. Clients should not
 make any assumptions about the returned implementations: implementations
 are free to change their internal structure at any time.

 @throws DatasetException]]>
      </doc>
    </method>
    <method name="newWriter" return="org.kitesdk.data.DatasetWriter&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get an appropriate {@link DatasetWriter} implementation based on this
 {@code View} of the underlying {@code Dataset} implementation.

 Implementations are free to return different types of writers depending on
 the disposition of the data. For example, a partitioned dataset may use a
 different writer than that of a non-partitioned dataset. Clients should not
 make any assumptions about the returned implementations: implementations
 are free to change their internal structure at any time.

 @throws DatasetException]]>
      </doc>
    </method>
    <method name="includes" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="entity" type="E"/>
      <doc>
      <![CDATA[Returns whether an entity {@link Object} would be included in this {@code View} if
 it were present in the {@code Dataset}.

 @param entity an entity {@code Object}
 @return true if {@code entity} is in the partition space of this view.
 @since 0.11.0]]>
      </doc>
    </method>
    <method name="deleteAll" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Deletes the entities included in this {@link View} or throws an
 {@link UnsupportedOperationException}.

 Implementations are allowed to throw {@code UnsupportedOperationException}
 if the {@code View} could require additional work to delete. For example,
 if some but not all of the data in an underlying data file must be removed,
 then the implementation is allowed to reject the deletion rather than
 copy the remaining records to a new file. Implementations must  document
 what deletes are supported and under what conditions deletes are rejected.

 @return true if any data was deleted, false if the View was already empty
 @throws UnsupportedOperationException
          if the requested delete cannot be completed by the implementation
 @throws DatasetIOException
          if the requested delete failed because of an IOException
 @since 0.12.0]]>
      </doc>
    </method>
    <method name="getType" return="java.lang.Class&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the runtime type of entities contained in this {@code View}.

 @return the runtime type of entities contained in this view

 @since 0.15.0]]>
      </doc>
    </method>
    <method name="getSchema" return="org.apache.avro.Schema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the schema of entities contained in this {@code View}.

 @return the schema of entities contained in this view

 @since 1.1.0]]>
      </doc>
    </method>
    <method name="isEmpty" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Check whether this {@link View} contains any records.

 Implementations should return once a single record in this view is found.
 But this might require scanning through large amounts of data sequentially
 to determine if there are any records.

 @return {@code true} if least one record exists, {@code false} otherwise
 @since 0.15.0]]>
      </doc>
    </method>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get a {@link URI} that identifies this {@code View}.

 @return a {@link URI} for this view.

 @since 0.16.0]]>
      </doc>
    </method>
    <method name="getCoveringPartitions" return="java.lang.Iterable&lt;org.kitesdk.data.PartitionView&lt;E&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns an {@code Iterable} of non-overlapping {@link View} objects that
 partition the underlying {@link Dataset} and cover this {@code View}.

 The returned {@code View} objects are implementation-specific, but should
 represent reasonable partitions of the underlying {@code Dataset} based on
 its layout.

 The data contained by the union of each {@code View} in the
 {@code Iterable} must be a super-set of this {@code View}.

 Note that partitions are actual partitions under which data is stored.
 Implementations should omit any {@code View} that is empty.

 @return
      An Iterable of the {@code View} that cover this {@code View}.
 @throws IllegalStateException
      If the underlying {@code Dataset} is not partitioned.
 @throws UnsupportedOperationException
      If the implementation does not support covering partitions.
 @since 1.1.0]]>
      </doc>
    </method>
    <method name="asSchema" return="org.kitesdk.data.View&lt;org.apache.avro.generic.GenericRecord&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.avro.Schema"/>
      <doc>
      <![CDATA[Creates a copy of this {@code View} that projects entities to the given
 {@link Schema}.
 <p>
 This method always returns a {@code View} with type {@link GenericRecord}.

 @param schema an Avro schema to project entities to
 @return a copy of this view that projects entities to the given schema
 @throws IncompatibleSchemaException
          If the given {@code schema} is incompatible with the underlying
          dataset.

 @since 1.1.0]]>
      </doc>
    </method>
    <method name="asType" return="org.kitesdk.data.View&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <doc>
      <![CDATA[Creates a copy of this {@code View} that reads and writes entities of the
 given type class.

 @param <T> the type of entities that will be read or written by this view
 @param type an entity class to use
 @return a copy of this view that projects entities to the given type
 @throws IncompatibleSchemaException
          If the given {@code type} is incompatible with the underlying
          dataset.

 @since 1.1.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A {@code View} is a subset of a {@link Dataset}.

 A {@code View} defines a space of potential storage keys or a partition
 space. Views can be created from ranges, partial keys, or the union of other
 views.

 @param <E>
      The type of entities stored in the {@code Dataset} underlying this
      {@code View}.
 @since 0.9.0]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.data.View -->
</package>
<package name="org.kitesdk.data.crunch">
  <!-- start class org.kitesdk.data.crunch.CrunchDatasets -->
  <class name="CrunchDatasets" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CrunchDatasets"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="asSource" return="org.apache.crunch.io.ReadableSource&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="view" type="org.kitesdk.data.View&lt;E&gt;"/>
      <doc>
      <![CDATA[Expose the given {@link View} as a Crunch {@link ReadableSource}.

 @param view the view to read from
 @param <E>     the type of entity produced by the source
 @return a {@link ReadableSource} for the view

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="asSource" return="org.apache.crunch.io.ReadableSource&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Expose the {@link View} or {@link Dataset} represented by the URI
 as a Crunch {@link ReadableSource}.

 @param uri the URI of the view or dataset to read from
 @param type    the Java type of the entities in the dataset
 @param <E>     the type of entity produced by the source
 @return a {@link ReadableSource} for the view

 @since 0.15.0]]>
      </doc>
    </method>
    <method name="asSource" return="org.apache.crunch.io.ReadableSource&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Expose the {@link View} or {@link Dataset} represented by the URI
 as a Crunch {@link ReadableSource}.

 @param uri the URI of the view or dataset to read from
 @param type    the Java type of the entities in the dataset
 @param <E>     the type of entity produced by the source
 @return a {@link ReadableSource} for the view

 @since 0.15.0]]>
      </doc>
    </method>
    <method name="asTarget" return="org.apache.crunch.Target"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="view" type="org.kitesdk.data.View&lt;E&gt;"/>
      <doc>
      <![CDATA[Expose the given {@link View} as a Crunch {@link Target}.

 @param view the view to write to
 @param <E>  the type of entity stored in the view
 @return a {@link Target} for the view

 @since 0.14.0]]>
      </doc>
    </method>
    <method name="asTarget" return="org.apache.crunch.Target"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Expose the {@link Dataset} or {@link View} represented by the given
 URI as a Crunch {@link Target}.

 @param uri the dataset or view URI
 @return a {@link Target} for the dataset or view

 @since 0.15.0]]>
      </doc>
    </method>
    <method name="asTarget" return="org.apache.crunch.Target"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Expose the {@link Dataset} or {@link View} represented by the given
 URI as a Crunch {@link Target}.

 @param uri the dataset or view URI
 @return a {@link Target} for the dataset or view

 @since 0.15.0]]>
      </doc>
    </method>
    <method name="partition" return="org.apache.crunch.PCollection&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="org.apache.crunch.PCollection&lt;E&gt;"/>
      <param name="view" type="org.kitesdk.data.View&lt;E&gt;"/>
      <doc>
      <![CDATA[Partitions {@code collection} to be stored efficiently in {@code View}.
 <p>
 This restructures the parallel collection so that all of the entities that
 will be stored in a given partition will be processed by the same writer.

 @param collection a collection of entities
 @param view a {@link View} of a dataset to partition the collection for
 @param <E> the type of entities in the collection and underlying dataset
 @return an equivalent collection of entities partitioned for the view

 @since 0.16.0]]>
      </doc>
    </method>
    <method name="partition" return="org.apache.crunch.PCollection&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="org.apache.crunch.PCollection&lt;E&gt;"/>
      <param name="dataset" type="org.kitesdk.data.Dataset&lt;E&gt;"/>
      <doc>
      <![CDATA[Partitions {@code collection} to be stored efficiently in {@code dataset}.
 <p>
 This restructures the parallel collection so that all of the entities that
 will be stored in a given partition will be processed by the same writer.

 @param collection a collection of entities
 @param dataset a dataset to partition the collection for
 @param <E> the type of entities in the collection and underlying dataset
 @return an equivalent collection of entities partitioned for the view

 @since 0.16.0]]>
      </doc>
    </method>
    <method name="partition" return="org.apache.crunch.PCollection&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="org.apache.crunch.PCollection&lt;E&gt;"/>
      <param name="view" type="org.kitesdk.data.View&lt;E&gt;"/>
      <param name="numWriters" type="int"/>
      <doc>
      <![CDATA[Partitions {@code collection} to be stored efficiently in {@code View}.
 <p>
 This restructures the parallel collection so that all of the entities that
 will be stored in a given partition will be processed by the same writer.
 <p>
 If the dataset is not partitioned, then this will structure all of the
 entities to produce a number of files equal to {@code numWriters}.

 @param collection a collection of entities
 @param view a {@link View} of a dataset to partition the collection for
 @param numWriters the number of writers that should be used
 @param <E> the type of entities in the collection and underlying dataset
 @return an equivalent collection of entities partitioned for the view
 @see #partition(PCollection, View)

 @since 0.16.0]]>
      </doc>
    </method>
    <method name="partition" return="org.apache.crunch.PCollection&lt;E&gt;"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collection" type="org.apache.crunch.PCollection&lt;E&gt;"/>
      <param name="view" type="org.kitesdk.data.View&lt;E&gt;"/>
      <param name="numWriters" type="int"/>
      <param name="numPartitionWriters" type="int"/>
      <doc>
      <![CDATA[Partitions {@code collection} to be stored efficiently in {@code View}.
 <p>
 This restructures the parallel collection so that all of the entities that
 will be stored in a given partition will be evenly distributed across a specified
 {@code numPartitionWriters}.
 <p>
 If the dataset is not partitioned, then this will structure all of the
 entities to produce a number of files equal to {@code numWriters}.

 @param collection a collection of entities
 @param view a {@link View} of a dataset to partition the collection for
 @param numWriters the number of writers that should be used
 @param numPartitionWriters the number of writers data for a single partition will be distributed across
 @param <E> the type of entities in the collection and underlying dataset
 @return an equivalent collection of entities partitioned for the view
 @see #partition(PCollection, View)

 @since 1.1.0]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 A helper class for exposing {@link Dataset}s and {@link View}s as Crunch
 {@link ReadableSource}s or {@link Target}s.
 </p>]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.crunch.CrunchDatasets -->
</package>
<package name="org.kitesdk.data.flume">
  <!-- start class org.kitesdk.data.flume.Log4jAppender -->
  <class name="Log4jAppender" extends="org.apache.flume.clients.log4jappender.Log4jAppender"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Log4jAppender"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="Log4jAppender" type="java.lang.String, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Sets the hostname and port. Even if these are passed the
 <tt>activateOptions()</tt> function must be called before calling
 <tt>append()</tt>, else <tt>append()</tt> will throw an Exception.
 @param hostname The first hop where the client should connect to.
 @param port The port to connect on the host.]]>
      </doc>
    </constructor>
    <method name="requiresLayout" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setDatasetRepositoryClass"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="Use datasetRepositoryUri with a 'repo:' URI.">
      <param name="datasetRepositoryClass" type="java.lang.String"/>
      <doc>
      <![CDATA[@deprecated Use datasetRepositoryUri with a 'repo:' URI.]]>
      </doc>
    </method>
    <method name="setDatasetRepositoryUri"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="datasetRepositoryUri" type="java.lang.String"/>
    </method>
    <method name="setDatasetNamespace"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="datasetNamespace" type="java.lang.String"/>
    </method>
    <method name="setDatasetName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="datasetName" type="java.lang.String"/>
    </method>
    <method name="populateAvroHeaders"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="hdrs" type="java.util.Map&lt;java.lang.String, java.lang.String&gt;"/>
      <param name="schema" type="org.apache.avro.Schema"/>
      <param name="message" type="java.lang.Object"/>
    </method>
  </class>
  <!-- end class org.kitesdk.data.flume.Log4jAppender -->
</package>
<package name="org.kitesdk.data.mapreduce">
  <!-- start class org.kitesdk.data.mapreduce.DatasetKeyInputFormat -->
  <class name="DatasetKeyInputFormat" extends="org.apache.hadoop.mapreduce.InputFormat&lt;E, java.lang.Void&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="DatasetKeyInputFormat"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure" return="org.kitesdk.data.mapreduce.DatasetKeyInputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="job" type="org.apache.hadoop.mapreduce.Job"/>
      <doc>
      <![CDATA[Configures the {@code Job} to use the {@code DatasetKeyInputFormat} and
 returns a helper to add further configuration.

 @param job the {@code Job} to configure

 @since 0.15.0]]>
      </doc>
    </method>
    <method name="configure" return="org.kitesdk.data.mapreduce.DatasetKeyInputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Adds settings to {@code Configuration} to use {@code DatasetKeyInputFormat}
 and returns a helper to add further configuration.

 @param conf a {@code Configuration}

 @since 0.15.0]]>
      </doc>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configuration" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getSplits" return="java.util.List&lt;org.apache.hadoop.mapreduce.InputSplit&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jobContext" type="org.apache.hadoop.mapreduce.JobContext"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="createRecordReader" return="org.apache.hadoop.mapreduce.RecordReader&lt;E, java.lang.Void&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="inputSplit" type="org.apache.hadoop.mapreduce.InputSplit"/>
      <param name="taskAttemptContext" type="org.apache.hadoop.mapreduce.TaskAttemptContext"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <field name="KITE_INPUT_URI" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KITE_PARTITION_DIR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KITE_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KITE_READER_SCHEMA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A MapReduce {@code InputFormat} for reading from a {@link Dataset}.

 Since a {@code Dataset} only contains entities (not key/value pairs), this output
 format ignores the value.

 @param <E> The type of entities in the {@code Dataset}.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.mapreduce.DatasetKeyInputFormat -->
  <!-- start class org.kitesdk.data.mapreduce.DatasetKeyInputFormat.ConfigBuilder -->
  <class name="DatasetKeyInputFormat.ConfigBuilder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="readFrom" return="org.kitesdk.data.mapreduce.DatasetKeyInputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Adds configuration for {@code DatasetKeyInputFormat} to read from the
 given dataset or view URI.
 <p>
 URI formats are defined by {@link Dataset} implementations, but must
 begin with "dataset:" or "view:". For more information, see
 {@link Datasets}.

 @param uri a dataset or view URI
 @return this for method chaining]]>
      </doc>
    </method>
    <method name="readFrom" return="org.kitesdk.data.mapreduce.DatasetKeyInputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="view" type="org.kitesdk.data.View&lt;?&gt;"/>
      <doc>
      <![CDATA[Adds configuration for {@code DatasetKeyInputFormat} to read from the
 given {@link Dataset} or {@link View} instance.

 @param view a dataset or view
 @return this for method chaining]]>
      </doc>
    </method>
    <method name="readFrom" return="org.kitesdk.data.mapreduce.DatasetKeyInputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds configuration for {@code DatasetKeyInputFormat} to read from the
 given dataset or view URI string.
 <p>
 URI formats are defined by {@link Dataset} implementations, but must
 begin with "dataset:" or "view:". For more information, see
 {@link Datasets}.

 @param uri a dataset or view URI string
 @return this for method chaining]]>
      </doc>
    </method>
    <method name="withType" return="org.kitesdk.data.mapreduce.DatasetKeyInputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Sets the entity Class that the input Dataset should produce.
 <p>
 This Class is used to configure the input {@code Dataset}. If this class
 cannot be found during job setup, the job will fail and throw a
 {@link org.kitesdk.data.TypeNotFoundException}.
 <p>
 If the type is set, then the type's schema is used for the expected
 schema and {@link #withSchema(Schema)} should not be called. This may,
 however, be used at the same time if the type is a generic record
 subclass.

 @param type the entity Class that will be produced
 @return this for method chaining]]>
      </doc>
    </method>
    <method name="withSchema" return="org.kitesdk.data.mapreduce.DatasetKeyInputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="readerSchema" type="org.apache.avro.Schema"/>
      <doc>
      <![CDATA[Sets the expected schema to use when reading records from the Dataset.
 <p>
 If this schema is set, {@link #withType(Class)} should only be called
 with a generic record subclass.

 @param readerSchema the expected entity schema
 @return this for method chaining
 @since 1.1.0]]>
      </doc>
    </method>
  </class>
  <!-- end class org.kitesdk.data.mapreduce.DatasetKeyInputFormat.ConfigBuilder -->
  <!-- start class org.kitesdk.data.mapreduce.DatasetKeyOutputFormat -->
  <class name="DatasetKeyOutputFormat" extends="org.apache.hadoop.mapreduce.OutputFormat&lt;E, java.lang.Void&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="DatasetKeyOutputFormat"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="job" type="org.apache.hadoop.mapreduce.Job"/>
      <doc>
      <![CDATA[Configures the {@code Job} to use the {@code DatasetKeyOutputFormat} and
 returns a helper to add further configuration.

 @param job the {@code Job} to configure

 @since 0.15.0]]>
      </doc>
    </method>
    <method name="configure" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Returns a helper to add output options to the given {@code Configuration}.

 @param conf a {@code Configuration}

 @since 0.15.0]]>
      </doc>
    </method>
    <method name="getRecordWriter" return="org.apache.hadoop.mapreduce.RecordWriter&lt;E, java.lang.Void&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="taskAttemptContext" type="org.apache.hadoop.mapreduce.TaskAttemptContext"/>
    </method>
    <method name="checkOutputSpecs"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jobContext" type="org.apache.hadoop.mapreduce.JobContext"/>
    </method>
    <method name="getOutputCommitter" return="org.apache.hadoop.mapreduce.OutputCommitter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="taskAttemptContext" type="org.apache.hadoop.mapreduce.TaskAttemptContext"/>
    </method>
    <field name="KITE_OUTPUT_URI" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KITE_PARTITION_DIR" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KITE_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KITE_WRITE_MODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="KITE_COPY_RECORDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A MapReduce {@code OutputFormat} for writing to a {@link Dataset}.

 Since a {@code Dataset} only contains entities (not key/value pairs), this output
 format ignores the value.

 @param <E> The type of entities in the {@code Dataset}.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.mapreduce.DatasetKeyOutputFormat -->
  <!-- start class org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder -->
  <class name="DatasetKeyOutputFormat.ConfigBuilder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="writeTo" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Adds configuration for {@code DatasetKeyOutputFormat} to write to the
 given dataset or view URI.
 <p>
 URI formats are defined by {@link Dataset} implementations, but must
 begin with "dataset:" or "view:". For more information, see
 {@link Datasets}.

 @param uri a dataset or view URI
 @return this for method chaining]]>
      </doc>
    </method>
    <method name="overwrite" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Adds configuration for {@code DatasetKeyOutputFormat} to write to the
 given dataset or view URI after removing any existing data.
 <p>
 The underlying dataset implementation must support View#deleteAll for
 the view identified by the URI or the job will fail.
 <p>
 URI formats are defined by {@link Dataset} implementations, but must
 begin with "dataset:" or "view:". For more information, see
 {@link Datasets}.

 @param uri a dataset or view URI
 @return this for method chaining

 @since 0.16.0]]>
      </doc>
    </method>
    <method name="appendTo" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <doc>
      <![CDATA[Adds configuration for {@code DatasetKeyOutputFormat} to append to the
 given dataset or view URI, leaving any existing data intact.
 <p>
 URI formats are defined by {@link Dataset} implementations, but must
 begin with "dataset:" or "view:". For more information, see
 {@link Datasets}.

 @param uri a dataset or view URI
 @return this for method chaining

 @since 0.16.0]]>
      </doc>
    </method>
    <method name="writeTo" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="view" type="org.kitesdk.data.View&lt;?&gt;"/>
      <doc>
      <![CDATA[Adds configuration for {@code DatasetKeyOutputFormat} to write to the
 given {@link Dataset} or {@link View} instance.

 @param view a dataset or view
 @return this for method chaining]]>
      </doc>
    </method>
    <method name="overwrite" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="view" type="org.kitesdk.data.View&lt;?&gt;"/>
      <doc>
      <![CDATA[Adds configuration for {@code DatasetKeyOutputFormat} to write to the
 given {@link Dataset} or {@link View} instance after removing any
 existing data.
 <p>
 The underlying dataset implementation must support View#deleteAll for
 the {@code view} or the job will fail.

 @param view a dataset or view
 @return this for method chaining

 @since 0.16.0]]>
      </doc>
    </method>
    <method name="appendTo" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="view" type="org.kitesdk.data.View&lt;?&gt;"/>
      <doc>
      <![CDATA[Adds configuration for {@code DatasetKeyOutputFormat} to append to the
 given dataset or view URI, leaving any existing data intact.

 @param view a dataset or view
 @return this for method chaining

 @since 0.16.0]]>
      </doc>
    </method>
    <method name="writeTo" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds configuration for {@code DatasetKeyOutputFormat} to write to the
 given dataset or view URI string.
 <p>
 URI formats are defined by {@link Dataset} implementations, but must
 begin with "dataset:" or "view:". For more information, see
 {@link Datasets}.

 @param uri a dataset or view URI string
 @return this for method chaining]]>
      </doc>
    </method>
    <method name="overwrite" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds configuration for {@code DatasetKeyOutputFormat} to write to the
 given dataset or view URI string after removing any existing data.
 <p>
 The underlying dataset implementation must support View#deleteAll for
 the view identified by the URI string or the job will fail.
 <p>
 URI formats are defined by {@link Dataset} implementations, but must
 begin with "dataset:" or "view:". For more information, see
 {@link Datasets}.

 @param uri a dataset or view URI string
 @return this for method chaining

 @since 0.16.0]]>
      </doc>
    </method>
    <method name="appendTo" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <doc>
      <![CDATA[Adds configuration for {@code DatasetKeyOutputFormat} to append to the
 given dataset or view URI, leaving any existing data intact.
 <p>
 URI formats are defined by {@link Dataset} implementations, but must
 begin with "dataset:" or "view:". For more information, see
 {@link Datasets}.

 @param uri a dataset or view URI string
 @return this for method chaining

 @since 0.16.0]]>
      </doc>
    </method>
    <method name="withType" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="type" type="java.lang.Class&lt;E&gt;"/>
      <doc>
      <![CDATA[Sets the entity Class that will be output by the Job.
 <p>
 This Class is used to configure the output {@code Dataset}.

 @param type the entity Class that will be produced
 @return this for method chaining]]>
      </doc>
    </method>
  </class>
  <!-- end class org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.ConfigBuilder -->
  <!-- start class org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.WriteMode -->
  <class name="DatasetKeyOutputFormat.WriteMode" extends="java.lang.Enum&lt;org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.WriteMode&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.WriteMode[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.WriteMode"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
  </class>
  <!-- end class org.kitesdk.data.mapreduce.DatasetKeyOutputFormat.WriteMode -->
</package>
<package name="org.kitesdk.data.oozie">
  <!-- start class org.kitesdk.data.oozie.KiteLauncherURIHandler -->
  <class name="KiteLauncherURIHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.oozie.action.hadoop.LauncherURIHandler"/>
    <constructor name="KiteLauncherURIHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="create" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="LauncherException" type="org.apache.oozie.action.hadoop.LauncherException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <exception name="LauncherException" type="org.apache.oozie.action.hadoop.LauncherException"/>
    </method>
    <method name="getClassesForLauncher" return="java.util.List&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.kitesdk.data.oozie.KiteLauncherURIHandler -->
  <!-- start class org.kitesdk.data.oozie.KiteURIHandler -->
  <class name="KiteURIHandler" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.oozie.dependency.URIHandler"/>
    <constructor name="KiteURIHandler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="init"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getSupportedSchemes" return="java.util.Set&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLauncherURIHandlerClass" return="java.lang.Class&lt;? extends org.apache.oozie.action.hadoop.LauncherURIHandler&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getClassesForLauncher" return="java.util.List&lt;java.lang.Class&lt;?&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getDependencyType" return="org.apache.oozie.dependency.URIHandler.DependencyType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <exception name="URIHandlerException" type="org.apache.oozie.dependency.URIHandlerException"/>
    </method>
    <method name="registerForNotification"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="user" type="java.lang.String"/>
      <param name="actionID" type="java.lang.String"/>
      <exception name="URIHandlerException" type="org.apache.oozie.dependency.URIHandlerException"/>
    </method>
    <method name="unregisterFromNotification" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="actionID" type="java.lang.String"/>
    </method>
    <method name="getContext" return="org.apache.oozie.dependency.URIHandler.Context"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="user" type="java.lang.String"/>
      <exception name="URIHandlerException" type="org.apache.oozie.dependency.URIHandlerException"/>
    </method>
    <method name="exists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="context" type="org.apache.oozie.dependency.URIHandler.Context"/>
      <exception name="URIHandlerException" type="org.apache.oozie.dependency.URIHandlerException"/>
    </method>
    <method name="exists" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.net.URI"/>
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="user" type="java.lang.String"/>
      <exception name="URIHandlerException" type="org.apache.oozie.dependency.URIHandlerException"/>
    </method>
    <method name="getURIWithDoneFlag" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <param name="doneFlag" type="java.lang.String"/>
      <exception name="URIHandlerException" type="org.apache.oozie.dependency.URIHandlerException"/>
    </method>
    <method name="validate"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="uri" type="java.lang.String"/>
      <exception name="URIHandlerException" type="org.apache.oozie.dependency.URIHandlerException"/>
    </method>
    <method name="destroy"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A Kite URI handler that works with {@link Signalable} views.

 To be considered as {@link #exists(URI, Configuration, String) existing} the
 view must have been signaled as ready.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.data.oozie.KiteURIHandler -->
</package>
<package name="org.kitesdk.minicluster">
  <!-- start class org.kitesdk.minicluster.FlumeService -->
  <class name="FlumeService" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.minicluster.Service"/>
    <constructor name="FlumeService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceConfig" type="org.kitesdk.minicluster.Service.ServiceConfig"/>
    </method>
    <method name="getHadoopConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="dependencies" return="java.util.List&lt;java.lang.Class&lt;? extends org.kitesdk.minicluster.Service&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
  </class>
  <!-- end class org.kitesdk.minicluster.FlumeService -->
  <!-- start class org.kitesdk.minicluster.HBaseService -->
  <class name="HBaseService" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.minicluster.Service"/>
    <constructor name="HBaseService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceConfig" type="org.kitesdk.minicluster.Service.ServiceConfig"/>
    </method>
    <method name="getHadoopConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="dependencies" return="java.util.List&lt;java.lang.Class&lt;? extends org.kitesdk.minicluster.Service&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="MASTER_PORT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Service configuration keys]]>
      </doc>
    </field>
    <field name="REGIONSERVER_PORT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An HBase minicluster service implementation.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.minicluster.HBaseService -->
  <!-- start class org.kitesdk.minicluster.HdfsService -->
  <class name="HdfsService" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.minicluster.Service"/>
    <constructor name="HdfsService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceConfig" type="org.kitesdk.minicluster.Service.ServiceConfig"/>
    </method>
    <method name="getHadoopConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="dependencies" return="java.util.List&lt;java.lang.Class&lt;? extends org.kitesdk.minicluster.Service&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="NAMENODE_HTTP_PORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Service configuration keys]]>
      </doc>
    </field>
    <field name="DATANODE_PORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DATANODE_IPC_PORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="DATANODE_HTTP_PORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[An HDFS minicluster service implementation.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.minicluster.HdfsService -->
  <!-- start class org.kitesdk.minicluster.HiveService -->
  <class name="HiveService" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.minicluster.Service"/>
    <constructor name="HiveService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceConfig" type="org.kitesdk.minicluster.Service.ServiceConfig"/>
    </method>
    <method name="getHadoopConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="dependencies" return="java.util.List&lt;java.lang.Class&lt;? extends org.kitesdk.minicluster.Service&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="startMetaStore" return="org.apache.thrift.server.TServer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="forceBindIP" type="java.lang.String"/>
      <param name="port" type="int"/>
      <param name="conf" type="org.apache.hadoop.hive.conf.HiveConf"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
  </class>
  <!-- end class org.kitesdk.minicluster.HiveService -->
  <!-- start class org.kitesdk.minicluster.MiniCluster -->
  <class name="MiniCluster" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="registerService"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="klass" type="java.lang.Class&lt;? extends org.kitesdk.minicluster.Service&gt;"/>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Starts the services in order, passing the previous service's modified
 Configuration object to the next.
 
 @throws IOException]]>
      </doc>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Stops the services in reverse of their run order.
 
 @throws IOException]]>
      </doc>
    </method>
    <field name="BIND_IP_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CLEAN_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="WORK_DIR_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NAMENODE_RPC_PORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ZK_PORT_KEY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HIVE_METASTORE_PORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="HIVE_SERVER_PORT" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLUME_CONFIGURATION" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="FLUME_AGENT_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A in process MiniCluster implementation for Kite that is configurable with
 Services that make up the MiniCluster. Examples of Services are HDFS, HBase,
 Zookeeper, etc...
 
 This MiniCluster should be built with its internal Builder class, which will
 validate proper configuration of the MiniCluster. For example, a Service can
 have dependencies, so the builder will validate that proper Service
 dependencies have been added to the MiniCluster.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.minicluster.MiniCluster -->
  <!-- start class org.kitesdk.minicluster.MiniCluster.Builder -->
  <class name="MiniCluster.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MiniCluster.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="hadoopConf" return="org.kitesdk.minicluster.MiniCluster.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hadoopConf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="workDir" return="org.kitesdk.minicluster.MiniCluster.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="workDir" type="java.lang.String"/>
    </method>
    <method name="clean" return="org.kitesdk.minicluster.MiniCluster.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="clean" type="boolean"/>
    </method>
    <method name="bindIP" return="org.kitesdk.minicluster.MiniCluster.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="bindIP" type="java.lang.String"/>
    </method>
    <method name="namenodeRpcPort" return="org.kitesdk.minicluster.MiniCluster.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="namenodeRpcPort" type="int"/>
    </method>
    <method name="zkPort" return="org.kitesdk.minicluster.MiniCluster.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="zkPort" type="int"/>
    </method>
    <method name="hiveMetastorePort" return="org.kitesdk.minicluster.MiniCluster.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="port" type="int"/>
    </method>
    <method name="hiveServerPort" return="org.kitesdk.minicluster.MiniCluster.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="port" type="int"/>
    </method>
    <method name="flumeConfiguration" return="org.kitesdk.minicluster.MiniCluster.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="resource" type="java.lang.String"/>
    </method>
    <method name="flumeAgentName" return="org.kitesdk.minicluster.MiniCluster.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="setServiceConfig" return="org.kitesdk.minicluster.MiniCluster.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
      <doc>
      <![CDATA[Service configs are dynamic config name-value pairs that can be
 interpreted by the services. This allows new services to be added that
 have their own encapsulated configuration parameters that don't need to
 be exposed statically from this Builder.
 
 @param name
          The name of the configuration parameter
 @param value
          The value of the config setting
 @return this Builder for method chaining.]]>
      </doc>
    </method>
    <method name="addService" return="org.kitesdk.minicluster.MiniCluster.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="klass" type="java.lang.Class&lt;? extends org.kitesdk.minicluster.Service&gt;"/>
    </method>
    <method name="build" return="org.kitesdk.minicluster.MiniCluster"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A MiniCluster Builder.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.minicluster.MiniCluster.Builder -->
  <!-- start interface org.kitesdk.minicluster.Service -->
  <interface name="Service"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceConfig" type="org.kitesdk.minicluster.Service.ServiceConfig"/>
      <doc>
      <![CDATA[Configure this service with the ServiceConfig
 
 @param serviceConfig
          A Service Config instance]]>
      </doc>
    </method>
    <method name="getHadoopConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the Hadoop configuration object for this service.
 
 @return The Hadoop configuration]]>
      </doc>
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Start the service.
 
 @throws IOException
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
      <doc>
      <![CDATA[Stop the service.
 
 @throws IOException
 @throws InterruptedException]]>
      </doc>
    </method>
    <method name="dependencies" return="java.util.List&lt;java.lang.Class&lt;? extends org.kitesdk.minicluster.Service&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Get the other Service implementations this Service has as a dependency. A
 mini cluster will validate that the dependencies are added, and that they
 are started before this one.
 
 @return The list of service dependencies.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface for MiniCluster Service implementations. Service implementation are
 generally constructed by the MiniCluster class.
 
 For this to be possible, implementations are expected to have a default
 constructor, and can automatically register themselves with the MiniCluster
 factory by having the static initializer:
 
 <pre>
 
 static {
   MiniCluster.registerService(MyService.class);
 }
 
 <pre>]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.minicluster.Service -->
  <!-- start class org.kitesdk.minicluster.Service.ServiceConfig -->
  <class name="Service.ServiceConfig" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="Service.ServiceConfig"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setHadoopConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="hadoopConf" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getHadoopConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="set"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
      <param name="value" type="java.lang.String"/>
    </method>
    <method name="get" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <method name="contains" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[A class that holds configuration settings for minicluster services.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.minicluster.Service.ServiceConfig -->
  <!-- start class org.kitesdk.minicluster.ZookeeperService -->
  <class name="ZookeeperService" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.minicluster.Service"/>
    <constructor name="ZookeeperService"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="serviceConfig" type="org.kitesdk.minicluster.Service.ServiceConfig"/>
    </method>
    <method name="getHadoopConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="start"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="InterruptedException" type="java.lang.InterruptedException"/>
    </method>
    <method name="stop"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="dependencies" return="java.util.List&lt;java.lang.Class&lt;? extends org.kitesdk.minicluster.Service&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A Zookeeper minicluster service implementation.
 
 This class was ripped from MiniZooKeeperCluster from the HBase tests. Changes
 made include:
 
 1. It will now only launch 1 zookeeper server.
 
 2. It will only attempt to bind to the port specified, and will fail if it
 can't.
 
 3. The startup method now takes a bindAddress, which allows us to configure
 which IP the ZK server binds to. This was not configurable in the original
 class.
 
 4. The ZK cluster will re-use a data dir on the local filesystem if it
 already exists instead of blowing it away.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.minicluster.ZookeeperService -->
</package>
<package name="org.kitesdk.morphline.api">
  <!-- start interface org.kitesdk.morphline.api.Command -->
  <interface name="Command"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="notify"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="notification" type="org.kitesdk.morphline.api.Record"/>
      <doc>
      <![CDATA[Processes the given notification on the control plane of the subtree rooted at this command.]]>
      </doc>
    </method>
    <method name="process" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.kitesdk.morphline.api.Record"/>
      <doc>
      <![CDATA[Processes the given record on the data plane of this command.
 
 @return true to indicate that processing shall continue, false to indicate that backtracking
         shall be done]]>
      </doc>
    </method>
    <method name="getParent" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the parent of this command. The parent of a command A is the command B that passes
 records to A. A is the child of B.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A command transforms a record into zero or more records.
 
 A command has a boolean return code, indicating success or failure. All record handlers in a
 morphline implement this interface. Commands are chained together. The parent of a command A is
 the command B that passes records to A. A is the child of B.
 
 Data is sent on the data plane whereas notifications are sent on the control plane, which is a
 separate communication channel.]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.morphline.api.Command -->
  <!-- start interface org.kitesdk.morphline.api.CommandBuilder -->
  <interface name="CommandBuilder"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the names with which this command can be invoked.
 
 The returned set can contain synonyms to enable backwards compatible name changes.]]>
      </doc>
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
      <doc>
      <![CDATA[Creates and returns a command rooted at the given morphline JSON <code>config</code>.
 
 The command will feed records into <code>child</code>. The command will have
 <code>parent</code> as it's parent. Additional parameters can be passed via the morphline
 <code>context</code>.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Interface to create instances of morphline commands.]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.morphline.api.CommandBuilder -->
  <!-- start interface org.kitesdk.morphline.api.ExceptionHandler -->
  <interface name="ExceptionHandler"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="handleException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="record" type="org.kitesdk.morphline.api.Record"/>
      <doc>
      <![CDATA[Handle the given exception resulting from the given input record (the record can be null)]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Morphline-wide default handler that commands can choose to use to handle exceptions.
 
 Mission critical, large-scale online production systems need to make progress without downtime
 despite some issues. Thus, the recommendation is that implementations of this handler rethrow
 exceptions in test mode, but try to log and continue in production mode, if that's considered
 appropriate and feasible.]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.morphline.api.ExceptionHandler -->
  <!-- start class org.kitesdk.morphline.api.MorphlineCompilationException -->
  <class name="MorphlineCompilationException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MorphlineCompilationException" type="java.lang.String, com.typesafe.config.Config"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MorphlineCompilationException" type="java.lang.String, com.typesafe.config.Config, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MorphlineCompilationException" type="java.lang.String, com.typesafe.config.Config, java.lang.Throwable, org.kitesdk.morphline.api.CommandBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Indicates a parse error.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.api.MorphlineCompilationException -->
  <!-- start class org.kitesdk.morphline.api.MorphlineContext -->
  <class name="MorphlineContext" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MorphlineContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[For public access use {@link Builder#build()} instead]]>
      </doc>
    </constructor>
    <method name="getSettings" return="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getTypedSettings" return="org.kitesdk.morphline.api.TypedSettings"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getExceptionHandler" return="org.kitesdk.morphline.api.ExceptionHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getMetricRegistry" return="com.codahale.metrics.MetricRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getHealthCheckRegistry" return="com.codahale.metrics.health.HealthCheckRegistry"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getCommandBuilder" return="java.lang.Class&lt;org.kitesdk.morphline.api.CommandBuilder&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="builderName" type="java.lang.String"/>
    </method>
    <method name="importCommandBuilders"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="importSpecs" type="java.util.Collection&lt;java.lang.String&gt;"/>
    </method>
    <doc>
    <![CDATA[Additional user defined parameters that will be passed to all morphline commands.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.api.MorphlineContext -->
  <!-- start class org.kitesdk.morphline.api.MorphlineContext.Builder -->
  <class name="MorphlineContext.Builder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MorphlineContext.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setSettings" return="org.kitesdk.morphline.api.MorphlineContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="settings" type="java.util.Map&lt;java.lang.String, java.lang.Object&gt;"/>
    </method>
    <method name="setExceptionHandler" return="org.kitesdk.morphline.api.MorphlineContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="exceptionHandler" type="org.kitesdk.morphline.api.ExceptionHandler"/>
    </method>
    <method name="setMetricRegistry" return="org.kitesdk.morphline.api.MorphlineContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metricRegistry" type="com.codahale.metrics.MetricRegistry"/>
    </method>
    <method name="setHealthCheckRegistry" return="org.kitesdk.morphline.api.MorphlineContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="healthCheckRegistry" type="com.codahale.metrics.health.HealthCheckRegistry"/>
    </method>
    <method name="build" return="org.kitesdk.morphline.api.MorphlineContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="create" return="org.kitesdk.morphline.api.MorphlineContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <field name="context" type="org.kitesdk.morphline.api.MorphlineContext"
      transient="false" volatile="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Helper to construct a {@link MorphlineContext} instance.
 
 Example usage: 
 
 <pre>
 MorphlineContext context = new MorphlineContext.Builder().setMetricRegistry(new MetricRegistry()).build();
 </pre>]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.api.MorphlineContext.Builder -->
  <!-- start class org.kitesdk.morphline.api.MorphlineRuntimeException -->
  <class name="MorphlineRuntimeException" extends="java.lang.RuntimeException"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="MorphlineRuntimeException" type="java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MorphlineRuntimeException" type="java.lang.String, java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="MorphlineRuntimeException" type="java.lang.Throwable"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <doc>
    <![CDATA[Base class of all morphline exceptions.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.api.MorphlineRuntimeException -->
  <!-- start class org.kitesdk.morphline.api.Record -->
  <class name="Record" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Record"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Creates a new empty record.]]>
      </doc>
    </constructor>
    <method name="copy" return="org.kitesdk.morphline.api.Record"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a shallow copy of this record.]]>
      </doc>
    </method>
    <method name="getFields" return="com.google.common.collect.ListMultimap&lt;java.lang.String, java.lang.Object&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the fields that are stored in this record.]]>
      </doc>
    </method>
    <method name="get" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns a view of the values associated with the given key. An empty collection may be
 returned, but never <code>null</null>.]]>
      </doc>
    </method>
    <method name="put"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds the given value to the values currently associated with the given key.]]>
      </doc>
    </method>
    <method name="getFirstValue" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Returns the first value associated with the given key, or null if no such value exists]]>
      </doc>
    </method>
    <method name="replaceValues"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Removes all values that are associated with the given key, and then associates the given value
 with the given key.]]>
      </doc>
    </method>
    <method name="removeAll"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <doc>
      <![CDATA[Removes all values that are associated with the given key]]>
      </doc>
    </method>
    <method name="putIfAbsent"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Adds the given value to the values currently associated with the given key, iff the key isn't
 already associated with that same value.]]>
      </doc>
    </method>
    <method name="equals" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="other" type="java.lang.Object"/>
    </method>
    <method name="hashCode" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A record is a set of named fields where each field has a list of one or more values.
 
 A value can be of any type, i.e. any Java Object. That is, a record is a {@link ListMultimap} as
 in Guava#s {@link ArrayListMultimap}. Note that a field can be multi-valued and that any two
 records need not use common field names. This flexible data model corresponds exactly to the
 characteristics of the Solr/Lucene data model (i.e. a record is a SolrInputDocument). A field
 with zero values is removed from the record - it does not exist as such.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.api.Record -->
  <!-- start class org.kitesdk.morphline.api.TypedSettings -->
  <class name="TypedSettings" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="getString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.String"/>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="defaultValue" type="boolean"/>
    </method>
    <method name="getInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="defaultValue" type="int"/>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="defaultValue" type="int"/>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="defaultValue" type="double"/>
    </method>
    <method name="getFloat" return="float"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="defaultValue" type="float"/>
    </method>
    <method name="getObject" return="java.lang.Object"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
      <param name="defaultValue" type="java.lang.Object"/>
    </method>
    <field name="DRY_RUN_SETTING_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TASK_CONTEXT_SETTING_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A Map with convenient typed accessors for reading values.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.api.TypedSettings -->
</package>
<package name="org.kitesdk.morphline.avro">
  <!-- start class org.kitesdk.morphline.avro.ExtractAvroPathsBuilder -->
  <class name="ExtractAvroPathsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractAvroPathsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that uses zero or more avro path expressions to extract values from an Avro object.
 
 The Avro input object is expected to be contained in the {@link Fields#ATTACHMENT_BODY}
 
 Each expression consists of a record output field name (on the left side of the colon ':') as
 well as zero or more path steps (on the right hand side), each path step separated by a '/'
 slash. Avro arrays are traversed with the '[]' notation.
 
 The result of a path expression is a list of objects, each of which is added to the given record
 output field.
 
 The path language supports all Avro concepts, including nested structures, records, arrays, maps,
 unions, etc, as well as a flatten option that collects the primitives in a subtree into a flat
 list.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.avro.ExtractAvroPathsBuilder -->
  <!-- start class org.kitesdk.morphline.avro.ExtractAvroTreeBuilder -->
  <class name="ExtractAvroTreeBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractAvroTreeBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts an attached Avro datum to a morphline record by recursively walking the
 Avro tree and extracting all data into a single morphline record, with fields named by their path
 in the Avro tree.
 
 The Avro input object is expected to be contained in the {@link Fields#ATTACHMENT_BODY}
 
 This kind of mapping is useful for simple Avro schemas, but a rather simplistic (and perhaps
 expensive) approach for complex Avro schemas.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.avro.ExtractAvroTreeBuilder -->
  <!-- start class org.kitesdk.morphline.avro.ReadAvroBuilder -->
  <class name="ReadAvroBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadAvroBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="AVRO_MEMORY_MIME_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The MIME type identifier that will be filled into output records]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Command that parses an InputStream that contains Avro data; for each Avro datum, the command
 emits a morphline record containing the datum as an attachment in {@link Fields#ATTACHMENT_BODY}.
 
 The Avro schema that was used to write the Avro data must be explicitly supplied. Optionally, the
 Avro schema that shall be used for reading can be supplied as well.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.avro.ReadAvroBuilder -->
  <!-- start class org.kitesdk.morphline.avro.ReadAvroContainerBuilder -->
  <class name="ReadAvroContainerBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadAvroContainerBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="MIME_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The MIME type that input attachments shall have]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Command that parses an InputStream that contains Avro binary container file data; for each Avro
 datum, the command emits a morphline record containing the datum as an attachment in
 {@link Fields#ATTACHMENT_BODY}.
 
 The Avro schema that was used to write the Avro data is retrieved from the container. Optionally, the
 Avro schema that shall be used for reading can be supplied as well.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.avro.ReadAvroContainerBuilder -->
  <!-- start class org.kitesdk.morphline.avro.ToAvroBuilder -->
  <class name="ToAvroBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ToAvroBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts a morphline record to an Avro record.

 @since 0.9.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.avro.ToAvroBuilder -->
  <!-- start class org.kitesdk.morphline.avro.ToAvroMapBuilder -->
  <class name="ToAvroMapBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ToAvroMapBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts a morphline record to an Avro record that contains a Map with string keys
 and array values where the array values can be null, boolean, int, long, float, double, string,
 bytes.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.avro.ToAvroMapBuilder -->
  <!-- start class org.kitesdk.morphline.avro.WriteAvroToByteArrayBuilder -->
  <class name="WriteAvroToByteArrayBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="WriteAvroToByteArrayBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that serializes the Avro records contained in the _attachment_body field into a byte
 array and replaces the _attachment_body field with that byte array.
 
 @since 0.9.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.avro.WriteAvroToByteArrayBuilder -->
</package>
<package name="org.kitesdk.morphline.base">
  <!-- start class org.kitesdk.morphline.base.AbstractCommand -->
  <class name="AbstractCommand" extends="java.lang.Object"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.Command"/>
    <constructor name="AbstractCommand" type="org.kitesdk.morphline.api.CommandBuilder, com.typesafe.config.Config, org.kitesdk.morphline.api.Command, org.kitesdk.morphline.api.Command, org.kitesdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Using the given <code>builder</code>, constructs a command rooted at the given morphline JSON
 <code>config</code>.
 
 The command will feed records into <code>child</code>. The command will have
 <code>parent</code> as it's parent. Additional parameters can be passed via the morphline
 <code>context</code>.]]>
      </doc>
    </constructor>
    <constructor name="AbstractCommand" type="com.typesafe.config.Config, org.kitesdk.morphline.api.Command, org.kitesdk.morphline.api.Command, org.kitesdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Deprecated; will be removed in the next release]]>
      </doc>
    </constructor>
    <method name="getParent" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getChild" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the child of this command. The parent of a command A is the command B that passes
 records to A. A is the child of B.]]>
      </doc>
    </method>
    <method name="getConfig" return="com.typesafe.config.Config"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the JSON configuration of this command.]]>
      </doc>
    </method>
    <method name="getContext" return="org.kitesdk.morphline.api.MorphlineContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns the context of this command.]]>
      </doc>
    </method>
    <method name="getConfigs" return="org.kitesdk.morphline.base.Configs"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns a helper for convenient access to the JSON configuration of this command.]]>
      </doc>
    </method>
    <method name="notify"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="notification" type="org.kitesdk.morphline.api.Record"/>
    </method>
    <method name="doNotify"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="notification" type="org.kitesdk.morphline.api.Record"/>
      <doc>
      <![CDATA[Processes the given notification on the control plane of the subtree rooted at this command.]]>
      </doc>
    </method>
    <method name="process" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.kitesdk.morphline.api.Record"/>
    </method>
    <method name="doProcess" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.kitesdk.morphline.api.Record"/>
      <doc>
      <![CDATA[Processes the given record on the data plane of this command.
 
 @return true to indicate that processing shall continue, false to indicate that backtracking
         shall be done]]>
      </doc>
    </method>
    <method name="validateArguments"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Helper that checks if the user provided configuration parameters are valid.]]>
      </doc>
    </method>
    <method name="getCounter" return="com.codahale.metrics.Counter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Returns a counter for maintaining main-memory metrics.]]>
      </doc>
    </method>
    <method name="getHistogram" return="com.codahale.metrics.Histogram"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Returns a histogram for maintaining main-memory metrics.]]>
      </doc>
    </method>
    <method name="getMeter" return="com.codahale.metrics.Meter"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Returns a meter for maintaining main-memory metrics.]]>
      </doc>
    </method>
    <method name="getTimer" return="com.codahale.metrics.Timer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="names" type="java.lang.String[]"/>
      <doc>
      <![CDATA[Returns a timer for maintaining main-memory metrics.]]>
      </doc>
    </method>
    <method name="isMeasuringMetrics" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Returns whether or not metrics should be measured.]]>
      </doc>
    </method>
    <method name="buildCommandChain" return="java.util.List&lt;org.kitesdk.morphline.api.Command&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="rootConfig" type="com.typesafe.config.Config"/>
      <param name="configKey" type="java.lang.String"/>
      <param name="finalChild" type="org.kitesdk.morphline.api.Command"/>
      <param name="ignoreNotifications" type="boolean"/>
      <doc>
      <![CDATA[Factory method to create the chain of commands rooted at the given rootConfig. The last command
 in the chain will feed records into finalChild.
 
 @param ignoreNotifications
          if true indicates don't forward notifications at the end of the chain of commands.
          This is a feature that multi-branch commands like tryRules and ifThenElse need to
          avoid sending a notification multiple times to finalChild, once from each branch.]]>
      </doc>
    </method>
    <method name="buildCommand" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="cmdConfig" type="com.typesafe.config.Config"/>
      <param name="currentParent" type="org.kitesdk.morphline.api.Command"/>
      <param name="finalChild" type="org.kitesdk.morphline.api.Command"/>
      <doc>
      <![CDATA[Factory method to create a command rooted at the given cmdConfig. The command will feed records
 into finalChild. The command will have currentParent as it's parent.]]>
      </doc>
    </method>
    <field name="LOG" type="org.slf4j.Logger"
      transient="false" volatile="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Base class for convenient implementation of {@link Command} classes.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.base.AbstractCommand -->
  <!-- start class org.kitesdk.morphline.base.Compiler -->
  <class name="Compiler" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Compiler"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="compile" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="morphlineFile" type="java.io.File"/>
      <param name="morphlineId" type="java.lang.String"/>
      <param name="morphlineContext" type="org.kitesdk.morphline.api.MorphlineContext"/>
      <param name="finalChild" type="org.kitesdk.morphline.api.Command"/>
      <param name="overrides" type="com.typesafe.config.Config[]"/>
      <doc>
      <![CDATA[Parses the given morphlineFile, then finds the morphline with the given morphlineId within,
 then compiles the morphline and returns the corresponding morphline command. The returned
 command will feed records into finalChild.]]>
      </doc>
    </method>
    <method name="parse" return="com.typesafe.config.Config"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="file" type="java.io.File"/>
      <param name="overrides" type="com.typesafe.config.Config[]"/>
      <exception name="IOException" type="java.io.IOException"/>
      <doc>
      <![CDATA[Loads the given config file from the local file system]]>
      </doc>
    </method>
    <method name="find" return="com.typesafe.config.Config"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="morphlineId" type="java.lang.String"/>
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="nameForErrorMsg" type="java.lang.String"/>
      <doc>
      <![CDATA[Finds the given morphline id within the given morphline config, using the given nameForErrorMsg
 for error reporting.]]>
      </doc>
    </method>
    <method name="compile" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="morphlineConfig" type="com.typesafe.config.Config"/>
      <param name="morphlineContext" type="org.kitesdk.morphline.api.MorphlineContext"/>
      <param name="finalChild" type="org.kitesdk.morphline.api.Command"/>
      <doc>
      <![CDATA[Compiles the given morphline config using the given morphline context. The returned command
 will feed records into finalChild or into /dev/null if finalChild is null.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Tool to parse and compile a morphline file or morphline config.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.base.Compiler -->
  <!-- start class org.kitesdk.morphline.base.Configs -->
  <class name="Configs" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Configs"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="validateArguments"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
    </method>
    <method name="getString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="java.lang.String"/>
    </method>
    <method name="getString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getStringList" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="java.util.List&lt;java.lang.String&gt;"/>
    </method>
    <method name="getStringList" return="java.util.List&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getConfigList" return="java.util.List&lt;? extends com.typesafe.config.Config&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="java.util.List&lt;? extends com.typesafe.config.Config&gt;"/>
    </method>
    <method name="getConfigList" return="java.util.List&lt;? extends com.typesafe.config.Config&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getConfig" return="com.typesafe.config.Config"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="com.typesafe.config.Config"/>
    </method>
    <method name="getConfig" return="com.typesafe.config.Config"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="boolean"/>
    </method>
    <method name="getBoolean" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="int"/>
    </method>
    <method name="getInt" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="long"/>
    </method>
    <method name="getLong" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="double"/>
    </method>
    <method name="getDouble" return="double"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getCharset" return="java.nio.charset.Charset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="java.nio.charset.Charset"/>
    </method>
    <method name="getNanoseconds" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="long"/>
    </method>
    <method name="getNanoseconds" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getTimeUnit" return="java.util.concurrent.TimeUnit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="java.util.concurrent.TimeUnit"/>
    </method>
    <method name="getTimeUnit" return="java.util.concurrent.TimeUnit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getTimeUnit" return="java.util.concurrent.TimeUnit"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="str" type="java.lang.String"/>
    </method>
    <method name="getLocale" return="java.util.Locale"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
      <param name="defaults" type="java.util.Locale"/>
    </method>
    <method name="getLocale" return="java.util.Locale"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="path" type="java.lang.String"/>
    </method>
    <method name="getEntrySet" return="java.util.Set&lt;java.util.Map.Entry&lt;java.lang.String, java.lang.Object&gt;&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
    </method>
    <doc>
    <![CDATA[Helpers to traverse and read parts of a HOCON data structure.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.base.Configs -->
  <!-- start class org.kitesdk.morphline.base.FaultTolerance -->
  <class name="FaultTolerance" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.ExceptionHandler"/>
    <constructor name="FaultTolerance" type="boolean, boolean"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <constructor name="FaultTolerance" type="boolean, boolean, java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="handleException"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="t" type="java.lang.Throwable"/>
      <param name="record" type="org.kitesdk.morphline.api.Record"/>
    </method>
    <field name="IS_PRODUCTION_MODE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="IS_IGNORING_RECOVERABLE_EXCEPTIONS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RECOVERABLE_EXCEPTION_CLASSES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Mission critical, large-scale online production systems need to make progress without downtime
 despite some issues.
 
 Some program exceptions tend to be transient, in which case the corresponding task can be
 retried. Examples include network connection errors, timeouts, etc. These are called recoverable
 exceptions.
 
 The isIgnoringRecoverableExceptions should only be enabled if an exception misclassification bug
 has been identified.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.base.FaultTolerance -->
  <!-- start class org.kitesdk.morphline.base.FieldExpression -->
  <class name="FieldExpression" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="FieldExpression" type="java.lang.String, com.typesafe.config.Config"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="evaluate" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="record" type="org.kitesdk.morphline.api.Record"/>
      <doc>
      <![CDATA[Returns the values of a {@link Record} referred to by the given field expression]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Helper to fetch the values of a field of a {@link Record} referred to by a field expression,
 which is a String of the form <code>@{fieldname}</code>.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.base.FieldExpression -->
  <!-- start class org.kitesdk.morphline.base.Fields -->
  <class name="Fields" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Fields"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="BASE_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="TIMESTAMP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MESSAGE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ATTACHMENT_BODY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ATTACHMENT_MIME_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ATTACHMENT_CHARSET" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ATTACHMENT_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Common record field names.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.base.Fields -->
  <!-- start class org.kitesdk.morphline.base.Metrics -->
  <class name="Metrics" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Metrics"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <field name="NUM_PROCESS_CALLS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NUM_NOTIFY_CALLS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NUM_RECORDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NUM_FAILED_RECORDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NUM_EXCEPTION_RECORDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NUM_CACHE_HITS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NUM_CACHE_MISSES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="NUM_FINAL_CHILD_RECORDS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="ELAPSED_TIME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="MORPHLINE_APP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Common metric names.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.base.Metrics -->
  <!-- start class org.kitesdk.morphline.base.Notifications -->
  <class name="Notifications" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Notifications"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getLifecycleEvents" return="java.util.List"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="notification" type="org.kitesdk.morphline.api.Record"/>
      <doc>
      <![CDATA[Get all lifecycle events from the given record.
 @return A {@link List} of {@link LifecycleEvent} enumerations representing all lifecycles stored in the given notification.]]>
      </doc>
    </method>
    <method name="notifyBeginTransaction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="org.kitesdk.morphline.api.Command"/>
      <doc>
      <![CDATA[Notify the given command that a transaction has begun.
 @param command The {@link Command} to be notified.]]>
      </doc>
    </method>
    <method name="notifyCommitTransaction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="org.kitesdk.morphline.api.Command"/>
      <doc>
      <![CDATA[Notify the given command that a transaction has been committed.
 @param command The {@link Command} to be notified.]]>
      </doc>
    </method>
    <method name="notifyRollbackTransaction"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="org.kitesdk.morphline.api.Command"/>
      <doc>
      <![CDATA[Notify the given command that a transaction has been rolled back.
 @param command The {@link Command} to be notified.]]>
      </doc>
    </method>
    <method name="notifyShutdown"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="org.kitesdk.morphline.api.Command"/>
      <doc>
      <![CDATA[Notify the given command that a shutdown command has been issued.
 @param command The {@link Command} to be notified.]]>
      </doc>
    </method>
    <method name="notifyStartSession"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="command" type="org.kitesdk.morphline.api.Command"/>
      <doc>
      <![CDATA[Notify the given command that a session has started.
 @param command The {@link Command} to be notified.]]>
      </doc>
    </method>
    <method name="containsLifecycleEvent" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="notification" type="org.kitesdk.morphline.api.Record"/>
      <param name="event" type="org.kitesdk.morphline.base.Notifications.LifecycleEvent"/>
      <doc>
      <![CDATA[Determine whether or not the given notification contains the given lifecycle event.
 @param notification A {@link Record} that represents a notification.
 @param event A {@link LifecycleEvent} enumeration that is to be searched for in the given notification.]]>
      </doc>
    </method>
    <field name="LIFE_CYCLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The field in which the notification of the lifecycle is stored.
 @since 0.10.1]]>
      </doc>
    </field>
    <field name="LIFE_CYLCLE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="(since 0.10.1) Use {@link #LIFE_CYCLE} instead.">
      <doc>
      <![CDATA[The field in which the notification of the lifecycle is stored.
 @deprecated (since 0.10.1) Use {@link #LIFE_CYCLE} instead.]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Tools for notifications on the control plane.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.base.Notifications -->
  <!-- start class org.kitesdk.morphline.base.Notifications.LifecycleEvent -->
  <class name="Notifications.LifecycleEvent" extends="java.lang.Enum&lt;org.kitesdk.morphline.base.Notifications.LifecycleEvent&gt;"
    abstract="false"
    static="true" final="true" visibility="public"
    deprecated="not deprecated">
    <method name="values" return="org.kitesdk.morphline.base.Notifications.LifecycleEvent[]"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="valueOf" return="org.kitesdk.morphline.base.Notifications.LifecycleEvent"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="name" type="java.lang.String"/>
    </method>
    <doc>
    <![CDATA[Enumerations of the standard lifecycle events.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.base.Notifications.LifecycleEvent -->
  <!-- start class org.kitesdk.morphline.base.PrettyPrinter -->
  <class name="PrettyPrinter" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="PrettyPrinter"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="main"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="args" type="java.lang.String[]"/>
    </method>
    <doc>
    <![CDATA[Utility to nicely indent and format a morphline config file.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.base.PrettyPrinter -->
  <!-- start class org.kitesdk.morphline.base.Validator -->
  <class name="Validator" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="Validator"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="validateRange"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="value" type="T"/>
      <param name="min" type="java.lang.Comparable&lt;T&gt;"/>
      <param name="max" type="java.lang.Comparable&lt;T&gt;"/>
      <doc>
      <![CDATA[Validates that the given value is contained in the range [min, max]]]>
      </doc>
    </method>
    <method name="validateEnum" return="T extends java.lang.Enum&lt;T&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="value" type="java.lang.String"/>
      <param name="type" type="java.lang.Class&lt;T&gt;"/>
      <param name="choices" type="T[]"/>
      <doc>
      <![CDATA[Validates that an enum of the given type with the given value exists, and that this enum is
 contained in the given list of permitted choices; finally returns that enum object.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Simple helper to validate user configurable parameters.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.base.Validator -->
</package>
<package name="org.kitesdk.morphline.hadoop.core">
  <!-- start class org.kitesdk.morphline.hadoop.core.DownloadHdfsFileBuilder -->
  <class name="DownloadHdfsFileBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="DownloadHdfsFileBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command for transferring HDFS files, for example to help with centralized configuration file
 management. On startup, the command downloads zero or more files or directory trees from HDFS to
 the local file system.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.hadoop.core.DownloadHdfsFileBuilder -->
  <!-- start class org.kitesdk.morphline.hadoop.core.OpenHdfsFileBuilder -->
  <class name="OpenHdfsFileBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="OpenHdfsFileBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Opens an HDFS file for read and return a corresponding InputStream.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.hadoop.core.OpenHdfsFileBuilder -->
</package>
<package name="org.kitesdk.morphline.hadoop.parquet.avro">
  <!-- start class org.kitesdk.morphline.hadoop.parquet.avro.ReadAvroParquetFileBuilder -->
  <class name="ReadAvroParquetFileBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadAvroParquetFileBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="FILE_UPLOAD_URL" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The morphline record field containing the HDFS Path of the Parquet file to read]]>
      </doc>
    </field>
    <field name="AVRO_MEMORY_MIME_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The MIME type identifier that will be filled into output records]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Command that parses a Hadoop File that contains Parquet data; for each Parquet Avro
 datum, the command emits a morphline record containing the record as an attachment in
 {@link Fields#ATTACHMENT_BODY}.
 
 The Avro schema that was used to write the data is retrieved from the Parquet file. Optionally, the
 Avro schema that shall be used for reading can be supplied as well.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.hadoop.parquet.avro.ReadAvroParquetFileBuilder -->
</package>
<package name="org.kitesdk.morphline.hadoop.rcfile">
  <!-- start class org.kitesdk.morphline.hadoop.rcfile.ReadRCFileBuilder -->
  <class name="ReadRCFileBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadRCFileBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="OUTPUT_MEDIA_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="RC_FILE_META_DATA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Command for reading Record Columnar (RC) Files. RCFile can be read in two
 ways

 1. Row Wise - Emits one record for every row in the RCFile, with columns
 mapped with names as provided in the column map

 2. Column Wise - For every row split (block) in the RC File, Emits one record
 for each column with all the row values for that column as a List

 For a RCFile with n rows and m columns. Row wise would emit n records and
 Column wise would emit m * (row splits) records.
 De-Compression is handled automatically]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.hadoop.rcfile.ReadRCFileBuilder -->
  <!-- start class org.kitesdk.morphline.hadoop.rcfile.SingleStreamFileSystem -->
  <class name="SingleStreamFileSystem" extends="org.apache.hadoop.fs.FileSystem"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <constructor name="SingleStreamFileSystem" type="java.io.InputStream, org.apache.hadoop.fs.Path"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </constructor>
    <method name="getUri" return="java.net.URI"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="open" return="org.apache.hadoop.fs.FSDataInputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="create" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <param name="overwrite" type="boolean"/>
      <param name="bufferSize" type="int"/>
      <param name="replication" type="short"/>
      <param name="blockSize" type="long"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="append" return="org.apache.hadoop.fs.FSDataOutputStream"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="bufferSize" type="int"/>
      <param name="progress" type="org.apache.hadoop.util.Progressable"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rename" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="src" type="org.apache.hadoop.fs.Path"/>
      <param name="dst" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="recursive" type="boolean"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="listStatus" return="org.apache.hadoop.fs.FileStatus[]"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="FileNotFoundException" type="java.io.FileNotFoundException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setWorkingDirectory"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="new_dir" type="org.apache.hadoop.fs.Path"/>
    </method>
    <method name="getWorkingDirectory" return="org.apache.hadoop.fs.Path"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="mkdirs" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <param name="permission" type="org.apache.hadoop.fs.permission.FsPermission"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getFileStatus" return="org.apache.hadoop.fs.FileStatus"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="f" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="delete" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="path" type="org.apache.hadoop.fs.Path"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[Very simple Filesystem Implementation which serves an InputStream for a given
 path. This is used to serve the underlying input stream from a FileSystem
 Interface. Only open() and getFileStatus() is implemented.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.hadoop.rcfile.SingleStreamFileSystem -->
</package>
<package name="org.kitesdk.morphline.hadoop.sequencefile">
  <!-- start class org.kitesdk.morphline.hadoop.sequencefile.ReadSequenceFileBuilder -->
  <class name="ReadSequenceFileBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadSequenceFileBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="OUTPUT_MEDIA_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="SEQUENCE_FILE_META_DATA" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CONFIG_KEY_FIELD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="CONFIG_VALUE_FIELD" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Command that emits one record per sequence file entry in the input stream of the first attachment.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.hadoop.sequencefile.ReadSequenceFileBuilder -->
</package>
<package name="org.kitesdk.morphline.json">
  <!-- start class org.kitesdk.morphline.json.ExtractJsonPathsBuilder -->
  <class name="ExtractJsonPathsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractJsonPathsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that uses zero or more JSON path expressions to extract values from a JSON object.
 
 The JSON input object is expected to be contained in the {@link Fields#ATTACHMENT_BODY}
 
 Each expression consists of a record output field name (on the left side of the colon ':') as
 well as zero or more path steps (on the right hand side), each path step separated by a '/'
 slash. JSON arrays are traversed with the '[]' notation.
 
 The result of a path expression is a list of objects, each of which is added to the given record
 output field.
 
 The path language supports all JSON concepts, including nested structures, records, arrays, etc,
 as well as a flatten option that collects the primitives in a subtree into a flat list.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.json.ExtractJsonPathsBuilder -->
  <!-- start class org.kitesdk.morphline.json.ReadJsonBuilder -->
  <class name="ReadJsonBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadJsonBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="MIME_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The MIME type identifier that will be filled into output records]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Command that parses an InputStream that contains JSON data; for each JSON object in the stream,
 the command emits a morphline record containing the object as an attachment in
 {@link Fields#ATTACHMENT_BODY}.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.json.ReadJsonBuilder -->
</package>
<package name="org.kitesdk.morphline.maxmind">
  <!-- start class org.kitesdk.morphline.maxmind.GeoIPBuilder -->
  <class name="GeoIPBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="GeoIPBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that returns Geolocation information for a given IP address, using an efficient in-memory
 Maxmind database lookup.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.maxmind.GeoIPBuilder -->
</package>
<package name="org.kitesdk.morphline.metrics.servlets">
  <!-- start class org.kitesdk.morphline.metrics.servlets.RegisterJVMMetricsBuilder -->
  <class name="RegisterJVMMetricsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="RegisterJVMMetricsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that registers metrics that are related to the Java Virtual Machine with the
 MorphlineContext of the morphline. For example, this includes metrics for garbage collection
 events, buffer pools, threads and thread deadlocks.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.metrics.servlets.RegisterJVMMetricsBuilder -->
  <!-- start class org.kitesdk.morphline.metrics.servlets.StartReportingMetricsToHTTPBuilder -->
  <class name="StartReportingMetricsToHTTPBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="StartReportingMetricsToHTTPBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that exposes liveness status, health check status, metrics state and thread dumps via a
 set of HTTP URLs served by Jetty, using the AdminServlet.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.metrics.servlets.StartReportingMetricsToHTTPBuilder -->
</package>
<package name="org.kitesdk.morphline.protobuf">
  <!-- start class org.kitesdk.morphline.protobuf.ExtractProtobufPathsBuilder -->
  <class name="ExtractProtobufPathsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractProtobufPathsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Command that uses zero or more protocol buffer path expressions to extract
 values from a protocol buffer object.
 
 The protocol buffer input object is expected to be contained in the
 {@link Fields#ATTACHMENT_BODY}
 
 Each expression consists of a record output field name (on the left side of
 the colon ':') as well as zero or more path steps (on the right hand side),
 each path step separated by a '/' slash. Protocol buffer arrays are traversed
 with the '[]' notation.
 
 The result of a path expression is a list of objects, each of which is added
 to the given record output field.
 
 ExtractMethod option says what will results path to object. <li>toByteArray -
 pass protocol buffer bytes to next command <li>toString - pass toString value
 to next command <li>none - pass protocol buffer object to next command]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.protobuf.ExtractProtobufPathsBuilder -->
  <!-- start class org.kitesdk.morphline.protobuf.ReadProtobufBuilder -->
  <class name="ReadProtobufBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadProtobufBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <field name="MIME_TYPE" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[The MIME type identifier that will be filled into output records]]>
      </doc>
    </field>
    <doc>
    <![CDATA[Command that parses an InputStream that contains Protocol buffer data; the
 command emits a morphline record containing the object as an attachment in
 {@link Fields#ATTACHMENT_BODY}.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.protobuf.ReadProtobufBuilder -->
</package>
<package name="org.kitesdk.morphline.saxon">
  <!-- start class org.kitesdk.morphline.saxon.ConvertHTMLBuilder -->
  <class name="ConvertHTMLBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ConvertHTMLBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts HTML to XHTML using the <a
 href="http://ccil.org/~cowan/XML/tagsoup/">TagSoup</a> library.
 
 Instead of parsing well-formed or valid XML, this command parses HTML as it is found in the wild:
 poor, nasty and brutish, though quite often far from short. TagSoup (and hence this command) is
 designed for people who have to process this stuff using some semblance of a rational application
 design. By providing this converter, it allows standard XML tools to be applied to even the
 worst HTML.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.saxon.ConvertHTMLBuilder -->
  <!-- start class org.kitesdk.morphline.saxon.XQueryBuilder -->
  <class name="XQueryBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="XQueryBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that parses an InputStream that contains an XML document and runs the given XQuery over
 the XML document. For each item in the query result sequence, the command emits a morphline record
 containing the item's name-value pairs.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.saxon.XQueryBuilder -->
  <!-- start class org.kitesdk.morphline.saxon.XSLTBuilder -->
  <class name="XSLTBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="XSLTBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that parses an InputStream that contains an XML document and runs the given XSL Transform
 over the XML document. For each item in the query result sequence, the command emits a morphline
 record containing the item's name-value pairs.
 
 TODO: Add support for streaming via fragmentPath.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.saxon.XSLTBuilder -->
</package>
<package name="org.kitesdk.morphline.scriptengine.java">
  <!-- start class org.kitesdk.morphline.scriptengine.java.ScriptEvaluator -->
  <class name="ScriptEvaluator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="ScriptEvaluator" type="java.lang.String, java.lang.String, java.lang.Class&lt;T&gt;, java.lang.String[], java.lang.Class[], java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ScriptException" type="javax.script.ScriptException"/>
    </constructor>
    <constructor name="ScriptEvaluator" type="java.lang.String, java.lang.String, java.lang.Class&lt;T&gt;, java.lang.String[], java.lang.Class[], java.lang.Class[], java.lang.String"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="ScriptException" type="javax.script.ScriptException"/>
    </constructor>
    <method name="evaluate" return="T"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="params" type="java.lang.Object[]"/>
      <exception name="ScriptException" type="javax.script.ScriptException"/>
    </method>
    <doc>
    <![CDATA[Creates and compiles the given Java code block, wrapped into a Java method with the given return
 type and parameter types, along with a Java class definition that contains the given import
 statements.
 <p>
 Compilation is done in main memory, i.e. without writing to the filesystem.
 <p>
 The result is an object that can be executed (and reused) any number of times. This is a high
 performance implementation, using an optimized variant of https://scripting.dev.java.net/" (JSR
 223 Java Scripting). Calling {@link #evaluate(Object...)} just means calling
 {@link Method#invoke(Object, Object...)} and as such has the same minimal runtime cost, i.e.
 O(100M calls/sec/core).
 
 Instances of this class are thread-safe if the user provided script statements are thread-safe.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.scriptengine.java.ScriptEvaluator -->
</package>
<package name="org.kitesdk.morphline.solr">
  <!-- start interface org.kitesdk.morphline.solr.DocumentLoader -->
  <interface name="DocumentLoader"    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="beginTransaction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Begins a transaction]]>
      </doc>
    </method>
    <method name="load"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="doc" type="org.apache.solr.common.SolrInputDocument"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Loads the given document into the destination]]>
      </doc>
    </method>
    <method name="deleteById"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Deletes the document with the given id from the destination]]>
      </doc>
    </method>
    <method name="deleteByQuery"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Deletes the documents matching the given query from the destination]]>
      </doc>
    </method>
    <method name="commitTransaction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Sends any outstanding documents to the destination and waits for a positive
 or negative ack (i.e. exception). Depending on the outcome the caller
 should then commit or rollback the current flume transaction
 correspondingly.
 
 @throws IOException
           If there is a low-level I/O error.]]>
      </doc>
    </method>
    <method name="rollbackTransaction" return="org.apache.solr.client.solrj.response.UpdateResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Performs a rollback of all non-committed documents pending.
 <p>
 Note that this is not a true rollback as in databases. Content you have
 previously added may have already been committed due to autoCommit, buffer
 full, other client performing a commit etc. So this is only a best-effort
 rollback.
 
 @throws IOException
           If there is a low-level I/O error.]]>
      </doc>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Releases allocated resources]]>
      </doc>
    </method>
    <method name="ping" return="org.apache.solr.client.solrj.response.SolrPingResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <doc>
      <![CDATA[Issues a ping request to check if the server is alive
 
 @throws IOException
           If there is a low-level I/O error.]]>
      </doc>
    </method>
    <doc>
    <![CDATA[A vehicle to load (or delete) Solr documents into some kind of destination,
 such as a SolrServer or MapReduce RecordWriter;
 This class should be considered private and it's API is subject to change without notice.]]>
    </doc>
  </interface>
  <!-- end interface org.kitesdk.morphline.solr.DocumentLoader -->
  <!-- start class org.kitesdk.morphline.solr.GenerateSolrSequenceKeyBuilder -->
  <class name="GenerateSolrSequenceKeyBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="GenerateSolrSequenceKeyBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A command that assigns a record unique key that is the concatenation of the given
 <code>baseIdField</code> record field, followed by a running count of the record number within
 the current session. The count is reset to zero whenever a "startSession" notification is
 received.
 <p>
 For example, assume a CSV file containing multiple records but no unique ids, and the
 <code>baseIdField</code> field is the filesystem path of the file. Now this command can be used
 to assign the following record values to Solr's unique key field:
 <code>$path#0, $path#1, ... $path#N</code>.
 <p>
 The name of the unique key field is fetched from Solr's schema.xml file, as directed by the
 <code>solrLocator</code> configuration parameter.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.solr.GenerateSolrSequenceKeyBuilder -->
  <!-- start class org.kitesdk.morphline.solr.LoadSolrBuilder -->
  <class name="LoadSolrBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="LoadSolrBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="SOLR_LOCATOR_PARAM" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOAD_SOLR_DELETE_BY_ID" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOAD_SOLR_DELETE_BY_QUERY" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="LOAD_SOLR_CHILD_DOCUMENTS" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A command that loads (or deletes) a record into a SolrServer or MapReduce SolrOutputFormat.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.solr.LoadSolrBuilder -->
  <!-- start class org.kitesdk.morphline.solr.SanitizeUnknownSolrFieldsBuilder -->
  <class name="SanitizeUnknownSolrFieldsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="SanitizeUnknownSolrFieldsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that sanitizes record fields that are unknown to Solr schema.xml by either deleting them
 (renameToPrefix is absent or a zero length string), or by moving them to a field prefixed with
 the given renameToPrefix (e.g. renameToPrefix = "ignored_" to use typical dynamic Solr fields).
 <p>
 Recall that Solr throws an exception on any attempt to load a document that contains a field that
 isn't specified in schema.xml.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.solr.SanitizeUnknownSolrFieldsBuilder -->
  <!-- start class org.kitesdk.morphline.solr.SolrLocator -->
  <class name="SolrLocator" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SolrLocator" type="org.kitesdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="SolrLocator" type="com.typesafe.config.Config, org.kitesdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getSolrServer" return="org.apache.solr.client.solrj.SolrServer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getLoader" return="org.kitesdk.morphline.solr.DocumentLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIndexSchema" return="org.apache.solr.schema.IndexSchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toString" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="toConfig" return="com.typesafe.config.Config"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="key" type="java.lang.String"/>
    </method>
    <method name="getCollectionName" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setCollectionName"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="collectionName" type="java.lang.String"/>
    </method>
    <method name="getZkHost" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setZkHost"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="zkHost" type="java.lang.String"/>
    </method>
    <method name="getSolrHomeDir" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setSolrHomeDir"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="solrHomeDir" type="java.lang.String"/>
    </method>
    <method name="getServerUrl" return="java.lang.String"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setServerUrl"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="solrUrl" type="java.lang.String"/>
    </method>
    <method name="getBatchSize" return="int"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setBatchSize"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="batchSize" type="int"/>
    </method>
    <doc>
    <![CDATA[Set of configuration parameters that identify the location and schema of a Solr server or
 SolrCloud; Based on this information this class can return the schema and a corresponding
 {@link DocumentLoader}.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.solr.SolrLocator -->
  <!-- start class org.kitesdk.morphline.solr.SolrMorphlineContext -->
  <class name="SolrMorphlineContext" extends="org.kitesdk.morphline.api.MorphlineContext"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SolrMorphlineContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[For public access use {@link Builder#build()} instead]]>
      </doc>
    </constructor>
    <method name="getDocumentLoader" return="org.kitesdk.morphline.solr.DocumentLoader"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="getIndexSchema" return="org.apache.solr.schema.IndexSchema"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A context that is specific to Solr.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.solr.SolrMorphlineContext -->
  <!-- start class org.kitesdk.morphline.solr.SolrMorphlineContext.Builder -->
  <class name="SolrMorphlineContext.Builder" extends="org.kitesdk.morphline.api.MorphlineContext.Builder"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="SolrMorphlineContext.Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="setDocumentLoader" return="org.kitesdk.morphline.solr.SolrMorphlineContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="loader" type="org.kitesdk.morphline.solr.DocumentLoader"/>
    </method>
    <method name="setIndexSchema" return="org.kitesdk.morphline.solr.SolrMorphlineContext.Builder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="schema" type="org.apache.solr.schema.IndexSchema"/>
    </method>
    <method name="build" return="org.kitesdk.morphline.solr.SolrMorphlineContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="create" return="org.kitesdk.morphline.solr.SolrMorphlineContext"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[Helper to construct a {@link SolrMorphlineContext} instance.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.solr.SolrMorphlineContext.Builder -->
  <!-- start class org.kitesdk.morphline.solr.SolrServerDocumentLoader -->
  <class name="SolrServerDocumentLoader" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.solr.DocumentLoader"/>
    <constructor name="SolrServerDocumentLoader" type="org.apache.solr.client.solrj.SolrServer, int"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="beginTransaction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="load"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="doc" type="org.apache.solr.common.SolrInputDocument"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
    </method>
    <method name="deleteById"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="id" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
    </method>
    <method name="deleteByQuery"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="query" type="java.lang.String"/>
      <exception name="IOException" type="java.io.IOException"/>
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
    </method>
    <method name="commitTransaction"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="rollbackTransaction" return="org.apache.solr.client.solrj.response.UpdateResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="shutdown"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="ping" return="org.apache.solr.client.solrj.response.SolrPingResponse"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="SolrServerException" type="org.apache.solr.client.solrj.SolrServerException"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="getSolrServer" return="org.apache.solr.client.solrj.SolrServer"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <doc>
    <![CDATA[A vehicle to load (or delete) documents into a local or remote {@link SolrServer}.
 This class should be considered private and it's API is subject to change without notice.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.solr.SolrServerDocumentLoader -->
  <!-- start class org.kitesdk.morphline.solr.TokenizeTextBuilder -->
  <class name="TokenizeTextBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="TokenizeTextBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A command that uses the embedded Solr/Lucene Analyzer library to generate tokens from a text
 string, without sending data to a Solr server.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.solr.TokenizeTextBuilder -->
</package>
<package name="org.kitesdk.morphline.solrcell">
  <!-- start class org.kitesdk.morphline.solrcell.SolrCellBuilder -->
  <class name="SolrCellBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="SolrCellBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that pipes the first attachment of a record into one of the given Tika parsers, then maps
 the Tika output back to a record using SolrCell.
 <p>
 The Tika parser is chosen from the configurable list of parsers, depending on the MIME type
 specified in the input record. Typically, this requires an upstream DetectMimeTypeBuilder
 in a prior command.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.solrcell.SolrCellBuilder -->
  <!-- start class org.kitesdk.morphline.solrcell.StripNonCharSolrContentHandlerFactory -->
  <class name="StripNonCharSolrContentHandlerFactory" extends="org.apache.solr.handler.extraction.SolrContentHandlerFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="StripNonCharSolrContentHandlerFactory" type="java.util.Collection&lt;java.lang.String&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createSolrContentHandler" return="org.apache.solr.handler.extraction.SolrContentHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metadata" type="org.apache.tika.metadata.Metadata"/>
      <param name="params" type="org.apache.solr.common.params.SolrParams"/>
      <param name="schema" type="org.apache.solr.schema.IndexSchema"/>
    </method>
    <doc>
    <![CDATA[SolrContentHandler and associated factory that strips non-characters anhd trims on output.
 This prevents exceptions on parsing integer fields inside Solr server.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.solrcell.StripNonCharSolrContentHandlerFactory -->
  <!-- start class org.kitesdk.morphline.solrcell.TrimSolrContentHandlerFactory -->
  <class name="TrimSolrContentHandlerFactory" extends="org.apache.solr.handler.extraction.SolrContentHandlerFactory"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TrimSolrContentHandlerFactory" type="java.util.Collection&lt;java.lang.String&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="createSolrContentHandler" return="org.apache.solr.handler.extraction.SolrContentHandler"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="metadata" type="org.apache.tika.metadata.Metadata"/>
      <param name="params" type="org.apache.solr.common.params.SolrParams"/>
      <param name="schema" type="org.apache.solr.schema.IndexSchema"/>
    </method>
    <doc>
    <![CDATA[SolrContentHandler and associated factory that trims field values on output.
 This prevents exceptions on parsing integer fields inside Solr server.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.solrcell.TrimSolrContentHandlerFactory -->
</package>
<package name="org.kitesdk.morphline.stdio">
  <!-- start class org.kitesdk.morphline.stdio.AbstractParser -->
  <class name="AbstractParser" extends="org.kitesdk.morphline.base.AbstractCommand"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractParser" type="org.kitesdk.morphline.api.CommandBuilder, com.typesafe.config.Config, org.kitesdk.morphline.api.Command, org.kitesdk.morphline.api.Command, org.kitesdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AbstractParser" type="com.typesafe.config.Config, org.kitesdk.morphline.api.Command, org.kitesdk.morphline.api.Command, org.kitesdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Deprecated; will be removed in the next release]]>
      </doc>
    </constructor>
    <method name="addSupportedMimeType"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="mediaType" type="java.lang.String"/>
    </method>
    <method name="doProcess" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.kitesdk.morphline.api.Record"/>
    </method>
    <method name="doProcess" return="boolean"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.kitesdk.morphline.api.Record"/>
      <param name="stream" type="java.io.InputStream"/>
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="incrementNumRecords"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </method>
    <method name="detectCharset" return="java.nio.charset.Charset"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.kitesdk.morphline.api.Record"/>
      <param name="charset" type="java.nio.charset.Charset"/>
    </method>
    <method name="removeAttachments"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="outputRecord" type="org.kitesdk.morphline.api.Record"/>
    </method>
    <field name="SUPPORTED_MIME_TYPES" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[Base class for convenient implementation of morphline parsers.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdio.AbstractParser -->
  <!-- start class org.kitesdk.morphline.stdio.ReadBlobBuilder -->
  <class name="ReadBlobBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadBlobBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that emits one record for the entire input stream of the first attachment, interpreting
 the stream as a Binary Large Object (BLOB), i.e. emits a corresponding Java byte array.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdio.ReadBlobBuilder -->
  <!-- start class org.kitesdk.morphline.stdio.ReadClobBuilder -->
  <class name="ReadClobBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadClobBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that emits one record for the entire input stream of the first attachment, interpreting
 the stream as a Character Large Object (CLOB).]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdio.ReadClobBuilder -->
  <!-- start class org.kitesdk.morphline.stdio.ReadCSVBuilder -->
  <class name="ReadCSVBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadCSVBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that extracts zero or more records from the input stream of the first attachment, 
 representing a Comma Separated Values (CSV) file.
 
 For the format see http://www.creativyst.com/Doc/Articles/CSV/CSV01.htm.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdio.ReadCSVBuilder -->
  <!-- start class org.kitesdk.morphline.stdio.ReadLineBuilder -->
  <class name="ReadLineBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadLineBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that emits one record per line in the input stream of the first attachment.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdio.ReadLineBuilder -->
  <!-- start class org.kitesdk.morphline.stdio.ReadMultiLineBuilder -->
  <class name="ReadMultiLineBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadMultiLineBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Multiline log parser that collapse multiline messages into a single record; supports "regex",
 "what" and "negate" configuration parameters similar to logstash.
 
 For example, this can be used to parse log4j with stack traces. Also see
 https://gist.github.com/smougenot/3182192 and http://logstash.net/docs/1.1.12/filters/multiline]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdio.ReadMultiLineBuilder -->
</package>
<package name="org.kitesdk.morphline.stdlib">
  <!-- start class org.kitesdk.morphline.stdlib.AbstractFieldTransformCommand -->
  <class name="AbstractFieldTransformCommand" extends="org.kitesdk.morphline.base.AbstractCommand"
    abstract="true"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="AbstractFieldTransformCommand" type="org.kitesdk.morphline.api.CommandBuilder, com.typesafe.config.Config, org.kitesdk.morphline.api.Command, org.kitesdk.morphline.api.Command, org.kitesdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
    </constructor>
    <constructor name="AbstractFieldTransformCommand" type="com.typesafe.config.Config, org.kitesdk.morphline.api.Command, org.kitesdk.morphline.api.Command, org.kitesdk.morphline.api.MorphlineContext"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Deprecated; Will be removed in the next release]]>
      </doc>
    </constructor>
    <method name="doProcess" return="boolean"
      abstract="false" native="false" synchronized="false"
      static="false" final="true" visibility="protected"
      deprecated="not deprecated">
      <param name="record" type="org.kitesdk.morphline.api.Record"/>
    </method>
    <method name="transformFieldValue" return="java.lang.Object"
      abstract="true" native="false" synchronized="false"
      static="false" final="false" visibility="protected"
      deprecated="not deprecated">
      <param name="value" type="java.lang.Object"/>
      <doc>
      <![CDATA[Transforms the given input value to some output value]]>
      </doc>
    </method>
    <doc>
    <![CDATA[Base class for convenient implementation of commands that do in-place updates on a field.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.AbstractFieldTransformCommand -->
  <!-- start class org.kitesdk.morphline.stdlib.AddCurrentTimeBuilder -->
  <class name="AddCurrentTimeBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="AddCurrentTimeBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="FIELD_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PRESERVE_EXISTING_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A command that adds the result of {@link System#currentTimeMillis()} to a given output field.
 
 Typically, a <tt>convertTimestamp</tt> command is subsequently used to convert this timestamp to
 an application specific output format.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.AddCurrentTimeBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.AddLocalHostBuilder -->
  <class name="AddLocalHostBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="AddLocalHostBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="FIELD_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PRESERVE_EXISTING_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="USE_IP" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A command that adds the name or IP of the local host to a given output field.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.AddLocalHostBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.AddValuesBuilder -->
  <class name="AddValuesBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="AddValuesBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[For each input field value, add the value to the given record output field.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.AddValuesBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.AddValuesIfAbsentBuilder -->
  <class name="AddValuesIfAbsentBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="AddValuesIfAbsentBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[For each input field value, add the value to the given record output field if the value isn't
 already contained in that field.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.AddValuesIfAbsentBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.CallParentPipeBuilder -->
  <class name="CallParentPipeBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="CallParentPipeBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that routes records to the enclosing pipe morphline object.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.CallParentPipeBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.ContainsBuilder -->
  <class name="ContainsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ContainsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that succeeds if one of the field values of the given named field is equal to one of the
 the given values, and fails otherwise; Multiple fields can be named, in which case the results
 are ANDed.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.ContainsBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.ConvertTimestampBuilder -->
  <class name="ConvertTimestampBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ConvertTimestampBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts the timestamps in a given field from one of a set of input date formats (in
 an input timezone) to an output date format (in an output timezone), while respecting daylight
 savings time rules. Provides reasonable defaults for common use cases.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.ConvertTimestampBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.DecodeBase64Builder -->
  <class name="DecodeBase64Builder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="DecodeBase64Builder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts a Base64 encoded String to a byte[] per Section <cite>6.8. Base64
 Content-Transfer-Encoding</cite> of <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.DecodeBase64Builder -->
  <!-- start class org.kitesdk.morphline.stdlib.DropRecordBuilder -->
  <class name="DropRecordBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="DropRecordBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that silently consumes records without ever emitting any record - think /dev/null.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.DropRecordBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.EqualsBuilder -->
  <class name="EqualsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="EqualsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that succeeds if all field values of the given named fields are equal to the the given
 values, and fails otherwise.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.EqualsBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.ExtractURIComponentBuilder -->
  <class name="ExtractURIComponentBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractURIComponentBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A command that extracts a subcomponent from the URIs contained in the given input field and
 appends it to the given output fields.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.ExtractURIComponentBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.ExtractURIComponentsBuilder -->
  <class name="ExtractURIComponentsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractURIComponentsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A command that extracts subcomponents from the URIs contained in the given input field and
 appends them to output fields with the given prefix, namely scheme, authority, host, port, path,
 query, fragment, schemeSpecificPart, userInfo.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.ExtractURIComponentsBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.ExtractURIQueryParametersBuilder -->
  <class name="ExtractURIQueryParametersBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ExtractURIQueryParametersBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A command that extracts the query parameters with a given name from the URIs contained in the
 given input field and appends them to the given output field.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.ExtractURIQueryParametersBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.FindReplaceBuilder -->
  <class name="FindReplaceBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="FindReplaceBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that examines each string value in a given field and replaces each substring of the string value
 that matches the given string literal or grok pattern with the given replacement.
 
 This command also supports grok dictionaries in the same way as the {@link GrokBuilder}.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.FindReplaceBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.GenerateUUIDBuilder -->
  <class name="GenerateUUIDBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="GenerateUUIDBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <field name="FIELD_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PRESERVE_EXISTING_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <field name="PREFIX_NAME" type="java.lang.String"
      transient="false" volatile="false"
      static="true" final="true" visibility="public"
      deprecated="not deprecated">
    </field>
    <doc>
    <![CDATA[A command that sets a universally unique identifier on all records that are intercepted. By
 default this event header is named "id".]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.GenerateUUIDBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.GrokBuilder -->
  <class name="GrokBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="GrokBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[The Grok command uses regular expression pattern matching to extract structured fields from
 unstructured log data.
 <p>
 It is perfect for syslog logs, apache and other webserver logs, mysql logs, and in general, any
 log format that is generally written for humans and not computer consumption.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.GrokBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.HeadBuilder -->
  <class name="HeadBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="HeadBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that ignores all input records beyond the N-th record, thus emitting at most N records,
 akin to the Unix <code>head</code> command. This can be helpful to quickly test a morphline with
 the first few records from a larger dataset.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.HeadBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.IfThenElseBuilder -->
  <class name="IfThenElseBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="IfThenElseBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[An If-Then-Else command consists of a chain of zero or more conditions commands, as well as a
 chain of zero or or more commands that are processed if all conditions succeed ("then commands"),
 as well as a chain of zero or more commands that are processed if one of the conditions fails
 ("else commands").
 
 If one of the commands in the "then" chain or "else" chain fails then the entire "if" command
 fails (and the remaining commands in the "then" or "else" branch are skipped).]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.IfThenElseBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.JavaBuilder -->
  <class name="JavaBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="JavaBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[The "java" command compiles the given Java code block, wrapped into a Java method with a boolean
 return type and several parameters, along with a Java class definition that contains the given
 import statements. The code block can then be executed many times.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.JavaBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.LogDebugBuilder -->
  <class name="LogDebugBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="LogDebugBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that logs to slf4j at DEBUG level.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.LogDebugBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.LogErrorBuilder -->
  <class name="LogErrorBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="LogErrorBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that logs to slf4j at ERROR level.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.LogErrorBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.LogInfoBuilder -->
  <class name="LogInfoBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="LogInfoBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that logs to slf4j at INFO level.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.LogInfoBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.LogTraceBuilder -->
  <class name="LogTraceBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="LogTraceBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that logs to slf4j at TRACE level.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.LogTraceBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.LogWarnBuilder -->
  <class name="LogWarnBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="LogWarnBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that logs to slf4j at WARN level.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.LogWarnBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.NotBuilder -->
  <class name="NotBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="NotBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A Not command consists of one nested command, the boolean return value of which is inverted.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.NotBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.PipeBuilder -->
  <class name="PipeBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="PipeBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Factory to create morphline pipe instances.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.PipeBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.RemoveFieldsBuilder -->
  <class name="RemoveFieldsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="RemoveFieldsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Removes all record fields for which the field name matches at least one of the given blacklist
 predicates but none of the given whitelist predicates.
 
 If the blacklist specification is absent it defaults to MATCH ALL. If the whitelist specification
 is absent it defaults to MATCH NONE.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.RemoveFieldsBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.RemoveValuesBuilder -->
  <class name="RemoveValuesBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="RemoveValuesBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Removes all record field values for which all of the following conditions hold:
 
 1) the field name matches at least one of the given nameBlacklist predicates but none of the
 given nameWhitelist predicates.
 
 2) the field value matches at least one of the given valueBlacklist predicates but none of the
 given valueWhitelist predicates.
 
 If the blacklist specification is absent it defaults to MATCH ALL. If the whitelist specification
 is absent it defaults to MATCH NONE.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.RemoveValuesBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.ReplaceValuesBuilder -->
  <class name="ReplaceValuesBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReplaceValuesBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Replaces all record field values for which all of the following conditions hold:
 
 1) the field name matches at least one of the given nameBlacklist predicates but none of the
 given nameWhitelist predicates.
 
 2) the field value matches at least one of the given valueBlacklist predicates but none of the
 given valueWhitelist predicates.
 
 If the blacklist specification is absent it defaults to MATCH ALL. If the whitelist specification
 is absent it defaults to MATCH NONE.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.ReplaceValuesBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.SampleBuilder -->
  <class name="SampleBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="SampleBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that forwards each input record with a given probability to its child command, and
 silently ignores all other input records. Sampling is based on a random number generator. This
 can be helpful to easily test a morphline with a random subset of records from a large dataset.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.SampleBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.SeparateAttachmentsBuilder -->
  <class name="SeparateAttachmentsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="SeparateAttachmentsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that emits one output record for each attachment in the input record's list of
 attachments; The result is a list of records, each of which has at most one attachment.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.SeparateAttachmentsBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.SetValuesBuilder -->
  <class name="SetValuesBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="SetValuesBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[For each input field, set the given record output field to the same values.
 
 That is, first remove all values from the output field, then add new values.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.SetValuesBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.SplitBuilder -->
  <class name="SplitBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="SplitBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that divides strings into substrings, by recognizing a <i>separator</i> (a.k.a.
 "delimiter") which can be expressed as a single character, literal string, regular expression,
 {@link CharMatcher}, or by using a fixed substring length. This class provides the functionality
 of Guava's {@link Splitter} class as a morphline command.
 
 This command also supports grok dictionaries in the same way as the {@link GrokBuilder}.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.SplitBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.SplitKeyValueBuilder -->
  <class name="SplitKeyValueBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="SplitKeyValueBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that iterates over the items in a given record input field, interprets each item as a key-value
 pair where the key and value are separated by the given separator character, and adds the pair's
 value to the record field named after the pair's key.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.SplitKeyValueBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.StartReportingMetricsToCSVBuilder -->
  <class name="StartReportingMetricsToCSVBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="StartReportingMetricsToCSVBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that starts periodically appending the metrics of the
 {@code com.codahale.metrics.MetricRegistry} of the
 morphline context to a set of CSV files, configured via a
 {@code com.codahale.metrics.CsvReporter.Builder}. The CSV
 files are named after the metrics.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.StartReportingMetricsToCSVBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.StartReportingMetricsToJMXBuilder -->
  <class name="StartReportingMetricsToJMXBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="StartReportingMetricsToJMXBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that starts publishing the metrics of the
 {@code com.codahale.metrics.MetricRegistry} of the morphline context
 to JMX, configured via a {@code com.codahale.metrics.JmxReporter.Builder}.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.StartReportingMetricsToJMXBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.StartReportingMetricsToSLF4JBuilder -->
  <class name="StartReportingMetricsToSLF4JBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="StartReportingMetricsToSLF4JBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that starts periodically logging the metrics of the
 {@code com.codahale.metrics.MetricRegistry} of the
 morphline context to SLF4j, configured via a
 {@code com.codahale.metrics.Slf4jReporter.Builder}.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.StartReportingMetricsToSLF4JBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.ToByteArrayBuilder -->
  <class name="ToByteArrayBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ToByteArrayBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts the Java objects in a given field via <code>Object.toString()</code> to
 their string representation, and then via <code>String.getBytes(Charset)</code> to their byte
 array representation. If the input Java objects are already byte arrays the command does nothing.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.ToByteArrayBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.ToStringBuilder -->
  <class name="ToStringBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ToStringBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that converts the Java objects in a given field via <code>Object.toString()</code> to
 their string representation, and optionally also applies <code>String.trim()</code>.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.ToStringBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.TranslateBuilder -->
  <class name="TranslateBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="TranslateBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that examines each string value in a given field and replaces it with the replacement
 value defined in a given dictionary aka hash table.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.TranslateBuilder -->
  <!-- start class org.kitesdk.morphline.stdlib.TryRulesBuilder -->
  <class name="TryRulesBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="TryRulesBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[A tryRules command consists of zero or more rules.
 
 A rule consists of zero or more commands.
 
 The rules of a tryRules command are processed in top-down order. If one of the commands in a rule
 fails, the tryRules command stops processing of this rule, backtracks and tries the next rule,
 and so on, until a rule is found that runs all its commands to completion without failure (the
 rule succeeds). If a rule succeeds the remaining rules of the current tryRules command are
 skipped. If no rule succeeds the record remains unchanged, but a warning may be issued (the
 warning can be turned off) or an exception may be thrown (which is logged and ignored in
 production mode).
 
 Because a command can itself be a tryRules command, there can be tryRules commands with commands,
 nested inside tryRules, inside tryRules, recursively. This helps to implement arbitrarily complex
 functionality for advanced usage.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.stdlib.TryRulesBuilder -->
</package>
<package name="org.kitesdk.morphline.tika">
  <!-- start class org.kitesdk.morphline.tika.DetectMimeTypeBuilder -->
  <class name="DetectMimeTypeBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="DetectMimeTypeBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that auto-detects the MIME type of the first attachment, if no MIME type is defined yet.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.tika.DetectMimeTypeBuilder -->
</package>
<package name="org.kitesdk.morphline.tika.decompress">
  <!-- start class org.kitesdk.morphline.tika.decompress.DecompressBuilder -->
  <class name="DecompressBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="DecompressBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that decompresses the first attachment. Implementation adapted from Tika CompressorParser.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.tika.decompress.DecompressBuilder -->
  <!-- start class org.kitesdk.morphline.tika.decompress.UnpackBuilder -->
  <class name="UnpackBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="UnpackBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that unpacks the first attachment. Implementation adapted from Tika PackageParser.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.tika.decompress.UnpackBuilder -->
</package>
<package name="org.kitesdk.morphline.twitter">
  <!-- start class org.kitesdk.morphline.twitter.ReadJsonTestTweetsBuilder -->
  <class name="ReadJsonTestTweetsBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="ReadJsonTestTweetsBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[JSON parser that extracts search documents from twitter tweets obtained from the twitter 1% sample firehose with the delimited=length option.
 For background see https://dev.twitter.com/docs/api/1.1/get/statuses/sample.
 
 The JSON input format is documented at https://dev.twitter.com/docs/platform-objects/tweets]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.twitter.ReadJsonTestTweetsBuilder -->
</package>
<package name="org.kitesdk.morphline.useragent">
  <!-- start class org.kitesdk.morphline.useragent.UserAgentBuilder -->
  <class name="UserAgentBuilder" extends="java.lang.Object"
    abstract="false"
    static="false" final="true" visibility="public"
    deprecated="not deprecated">
    <implements name="org.kitesdk.morphline.api.CommandBuilder"/>
    <constructor name="UserAgentBuilder"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getNames" return="java.util.Collection&lt;java.lang.String&gt;"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="build" return="org.kitesdk.morphline.api.Command"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="config" type="com.typesafe.config.Config"/>
      <param name="parent" type="org.kitesdk.morphline.api.Command"/>
      <param name="child" type="org.kitesdk.morphline.api.Command"/>
      <param name="context" type="org.kitesdk.morphline.api.MorphlineContext"/>
    </method>
    <doc>
    <![CDATA[Command that parses user agent strings and returns structured higher level data like user agent
 family, operating system, version, and device type, using the underlying API and regexes.yaml
 BrowserScope database from https://github.com/tobie/ua-parser.]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.morphline.useragent.UserAgentBuilder -->
</package>
<package name="org.kitesdk.tools">
  <!-- start class org.kitesdk.tools.CompactionTask -->
  <class name="CompactionTask" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <implements name="org.apache.hadoop.conf.Configurable"/>
    <constructor name="CompactionTask" type="org.kitesdk.data.View&lt;T&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setNumWriters" return="org.kitesdk.tools.CompactionTask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="numWriters" type="int"/>
    </method>
    <method name="run" return="org.apache.crunch.PipelineResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <method name="setConf"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="configuration" type="org.apache.hadoop.conf.Configuration"/>
    </method>
    <method name="getConf" return="org.apache.hadoop.conf.Configuration"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="setFilesPerPartition"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filesPerPartition" type="int"/>
    </method>
    <doc>
    <![CDATA[@since 1.1.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.tools.CompactionTask -->
  <!-- start class org.kitesdk.tools.CopyTask -->
  <class name="CopyTask" extends="org.kitesdk.tools.TransformTask&lt;E, E&gt;"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="CopyTask" type="org.kitesdk.data.View&lt;E&gt;, org.kitesdk.data.View&lt;E&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[@since 0.16.0]]>
      </doc>
    </constructor>
  </class>
  <!-- end class org.kitesdk.tools.CopyTask -->
  <!-- start class org.kitesdk.tools.JobClasspathHelper -->
  <class name="JobClasspathHelper" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="JobClasspathHelper"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="prepareClasspath"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <param name="libDir" type="org.apache.hadoop.fs.Path"/>
      <param name="classesToInclude" type="java.lang.Class[]"/>
      <exception name="Exception" type="java.lang.Exception"/>
      <doc>
      <![CDATA[@param conf
            Configuration object for the Job. Used to get the FileSystem associated with it.
 @param libDir
            Destination directory in the FileSystem (Usually HDFS) where to upload and look for the libs.
 @param classesToInclude
            Classes that are needed by the job. JarFinder will look for the jar containing these classes.
 @throws Exception]]>
      </doc>
    </method>
    <doc>
    <![CDATA[<p>
 This class is an helper to copy the jars needed by the job in the Distributed cache.
 </p>
 
 <p>
 This tool helps to setup the job classpath at runtime. It allows library sharing between job. That result in faster
 jobs setup (since most of the time the libs are already uploaded in HDFS). Before submitting a job, you use this tool
 to provide the classes that you use in your job.
 </p>
 
 <p>
 The tool will find the jar(s), or will create the jars and upload them to a "library" path in HDFS, and it will
 create an md5 file along the uploaded jar.
 </p>
 
 <p>
 In order to find the jar or creating the job's Jar It use a modified version of org.apache.hadoop.util.JarFinder that
 is found in Hadoop 0.23
 </p>
 
 <p>
 If another job needs the same jar and provide the same "library" path it will discover it and use it, without having
 to lose the time that the upload of the jar would require.
 </p>
 
 <p>
 If the jar does not exist in the "library" path, it will upload it. However, if the jar is already in the "library"
 path, the tool will compute the md5 of the jar and compare with the one found in HDFS, and if there's a difference,
 the jar will be uploaded.
 </p>
 
 <p>
 If it creates a jar (from the classes of the job itself or from the classes in your workspace for example), it will
 upload the created jar to the "library" path and clean them after the JVM exits.
 </p>
 
 <p>
 Here's an example for a job class TestTool.class that requires HashFunction from Guava.
 </p>
 
 <pre>
 {@code
 new JobClasspathHelper().prepareClasspath(getConf(), new Path("/lib/path"), new Class[] { TestTool.class, HashFunction.class});
 }
 </pre>
 
 @author tbussier (tony.bussieres@ticksmith.com)
 @since 0.3.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.tools.JobClasspathHelper -->
  <!-- start class org.kitesdk.tools.TaskUtil -->
  <class name="TaskUtil" extends="java.lang.Object"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TaskUtil"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="configure" return="org.kitesdk.tools.TaskUtil.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="job" type="org.apache.hadoop.mapreduce.Job"/>
      <doc>
      <![CDATA[Returns a configuration builder for the given {@link Job}.
 @param job a {@code Job} to configure]]>
      </doc>
    </method>
    <method name="configure" return="org.kitesdk.tools.TaskUtil.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="true" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="conf" type="org.apache.hadoop.conf.Configuration"/>
      <doc>
      <![CDATA[Returns a configuration builder for the given {@link Configuration}.
 @param conf a {@code Configuration} to configure]]>
      </doc>
    </method>
  </class>
  <!-- end class org.kitesdk.tools.TaskUtil -->
  <!-- start class org.kitesdk.tools.TaskUtil.ConfigBuilder -->
  <class name="TaskUtil.ConfigBuilder" extends="java.lang.Object"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <method name="addJars" return="org.kitesdk.tools.TaskUtil.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="jars" type="java.util.List&lt;java.lang.String&gt;"/>
      <doc>
      <![CDATA[Adds a set of jar paths to the distributed cache.

 @param jars A list of jar paths
 @return this for method chaining

 @since 0.16.0]]>
      </doc>
    </method>
    <method name="addJarForClass" return="org.kitesdk.tools.TaskUtil.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="requiredClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Finds the jar that contains the required class and adds it to the
 distributed cache configuration.

 @param requiredClass a class required for a MR job
 @return this for method chaining]]>
      </doc>
    </method>
    <method name="addJarPathForClass" return="org.kitesdk.tools.TaskUtil.ConfigBuilder"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="requiredClass" type="java.lang.Class&lt;?&gt;"/>
      <doc>
      <![CDATA[Finds the jar that contains the required class and adds its containing
 directory to the distributed cache configuration.

 @param requiredClass a class required for a MR job
 @return this for method chaining]]>
      </doc>
    </method>
  </class>
  <!-- end class org.kitesdk.tools.TaskUtil.ConfigBuilder -->
  <!-- start class org.kitesdk.tools.TransformTask -->
  <class name="TransformTask" extends="org.apache.hadoop.conf.Configured"
    abstract="false"
    static="false" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TransformTask" type="org.kitesdk.data.View&lt;S&gt;, org.kitesdk.data.View&lt;T&gt;, org.apache.crunch.DoFn&lt;S, T&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="getCount" return="long"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </method>
    <method name="noCompaction" return="org.kitesdk.tools.TransformTask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <doc>
      <![CDATA[Do not shuffle data to writers to minimize the number of files. Write from
 each read task.

 @return this for method chaining]]>
      </doc>
    </method>
    <method name="setNumWriters" return="org.kitesdk.tools.TransformTask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="numWriters" type="int"/>
      <doc>
      <![CDATA[Set the number of concurrent writer processes.
 <p>
 If set to 0, this disables compaction.

 @param numWriters the number of concurrent writer processes
 @return this for method chaining]]>
      </doc>
    </method>
    <method name="setFilesPerPartition" return="org.kitesdk.tools.TransformTask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="filesPerPartition" type="int"/>
      <doc>
      <![CDATA[Set the number of files to create in each output partition.

 @param filesPerPartition a target number of files per output partition
 @return this for method chaining
 @since 1.1.0]]>
      </doc>
    </method>
    <method name="setWriteMode" return="org.kitesdk.tools.TransformTask"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="mode" type="org.apache.crunch.Target.WriteMode"/>
      <doc>
      <![CDATA[Set the output write mode: default, overwrite, or append.

 @param mode the output write mode
 @return this for method chaining]]>
      </doc>
    </method>
    <method name="run" return="org.apache.crunch.PipelineResult"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <exception name="IOException" type="java.io.IOException"/>
    </method>
    <doc>
    <![CDATA[@since 0.16.0]]>
    </doc>
  </class>
  <!-- end class org.kitesdk.tools.TransformTask -->
  <!-- start class org.kitesdk.tools.TransformTask.CheckEntityClass -->
  <class name="TransformTask.CheckEntityClass" extends="org.apache.crunch.MapFn&lt;E, E&gt;"
    abstract="false"
    static="true" final="false" visibility="public"
    deprecated="not deprecated">
    <constructor name="TransformTask.CheckEntityClass" type="java.lang.Class&lt;?&gt;"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
    </constructor>
    <method name="map" return="E"
      abstract="false" native="false" synchronized="false"
      static="false" final="false" visibility="public"
      deprecated="not deprecated">
      <param name="input" type="E"/>
    </method>
  </class>
  <!-- end class org.kitesdk.tools.TransformTask.CheckEntityClass -->
</package>

</api>
